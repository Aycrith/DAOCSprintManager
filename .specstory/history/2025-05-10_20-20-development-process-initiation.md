<!-- Generated by SpecStory -->

# Development Process Initiation (2025-05-10 16:20:33)

_**User**_

Using the instructions @AI_HANDOFF.md please start development

---

_**Assistant**_



---

I'll help you implement Phase 3, Task 3.2 (Part 1) - Profile Manager UI Framework & Tray Integration for the PyDAOC Sprint Manager project. Let's start by examining the current files and then implementing the required functionality.

---

<details>
            <summary>Listed directory src/daoc_sprint_manager/ui ‚Ä¢ **5** results</summary>
        
| Name |
|-------|
| üìÑ `tray_app.py` |
| üìÑ `config_gui.py` |
| üìÅ `__pycache__` |
| üìÑ `test_config_gui.py` |
| üìÑ `__init__.py` |

</details>

---

<details>
            <summary>Listed directory src/daoc_sprint_manager ‚Ä¢ **10** results</summary>
        
| Name |
|-------|
| üìÑ `data_models.py` |
| üìÅ `utils` |
| üìÑ `config_manager.py` |
| üìÑ `main.py` |
| üìÅ `__pycache__` |
| üìÅ `ui` |
| üìÅ `core` |
| üìÅ `data` |
| üìÑ `__init__.py` |
| üìÅ `logs` |

</details>

---

Now, let's examine the content of the required files to understand their structure and implementation details.

---

Read file: src/daoc_sprint_manager/data_models.py

---

Read file: src/daoc_sprint_manager/ui/tray_app.py

---

Read file: src/daoc_sprint_manager/ui/config_gui.py

---

Now, let's implement the required changes for this task. First, I'll create the `profile_manager_dialog.py` file and then update the `tray_app.py` file.

---

```diff
- 
+ """
+ Profile Manager Dialog for the DAOC Sprint Manager.
+ 
+ This module provides a Tkinter-based graphical user interface for managing application profiles.
+ """
+ 
+ import logging
+ import pathlib
+ import sys
+ import tkinter as tk
+ from tkinter import ttk, messagebox, filedialog
+ from typing import List, Optional, Callable, Dict, Any
+ import datetime
+ 
+ # Import project modules
+ try:
+     from ..data_models import Profile, AppSettings
+ except ImportError:
+     # For standalone testing or direct execution
+     import sys
+     from pathlib import Path
+     # Assumes profile_manager_dialog.py is in src/daoc_sprint_manager/ui
+     project_root = Path(__file__).resolve().parent.parent.parent
+     sys.path.insert(0, str(project_root / 'src'))
+     from daoc_sprint_manager.data_models import Profile, AppSettings
+ 
+ 
+ class ProfileManagerDialog(tk.Toplevel):
+     """
+     Tkinter-based Profile Manager dialog for the application.
+     
+     Provides a user interface for creating, editing, importing, and exporting profiles.
+     """
+     
+     def __init__(self, master: tk.Tk, config_manager, logger: logging.Logger, 
+                  profiles: List[Profile], on_close_callback: Optional[Callable] = None):
+         """
+         Initialize the Profile Manager dialog.
+         
+         Args:
+             master: The parent Tkinter window.
+             config_manager: ConfigManager or ProfileIOManager instance for profile operations.
+             logger: Logger instance for logging events.
+             profiles: List of currently available profiles.
+             on_close_callback: Optional callback function called when the dialog is closed.
+         """
+         super().__init__(master)
+         self.config_manager = config_manager
+         self.logger = logger
+         self.profiles = profiles[:]  # Make a copy of the profiles list
+         self.on_close_callback = on_close_callback
+         
+         # Set window properties
+         self.title("Profile Manager")
+         self.transient(master)  # Make dialog modal to master
+         self.grab_set()  # Make dialog modal
+         
+         # Set up the UI
+         self._setup_ui()
+         
+         # Center the window on the screen
+         self._center_window()
+         
+         # Set window close protocol
+         self.protocol("WM_DELETE_WINDOW", self._on_close)
+     
+     def _center_window(self):
+         """Center the dialog window on the screen."""
+         self.update_idletasks()
+         
+         # Get the dialog dimensions
+         width = self.winfo_reqwidth()
+         height = self.winfo_reqheight()
+         
+         # Get the screen dimensions
+         screen_width = self.winfo_screenwidth()
+         screen_height = self.winfo_screenheight()
+         
+         # Calculate position
+         x = (screen_width - width) // 2
+         y = (screen_height - height) // 2
+         
+         # Set the position
+         self.geometry(f"+{x}+{y}")
+     
+     def _setup_ui(self):
+         """Set up the UI components."""
+         # Create main content frame with padding
+         main_frame = ttk.Frame(self, padding="10")
+         main_frame.pack(expand=True, fill=tk.BOTH)
+         
+         # Profile List Display
+         list_frame = ttk.Frame(main_frame)
+         list_frame.pack(expand=True, fill=tk.BOTH, pady=(0, 10))
+         
+         # Create and configure Treeview
+         columns = ("ID", "Profile Name", "Character Name", "Last Used")
+         self.profile_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
+         
+         # Hide the ID column but keep it for reference
+         self.profile_tree.heading("ID", text="ID")
+         self.profile_tree.column("ID", width=0, stretch=tk.NO)
+         
+         # Configure visible columns
+         self.profile_tree.heading("Profile Name", text="Profile Name")
+         self.profile_tree.column("Profile Name", width=200, anchor=tk.W)
+         
+         self.profile_tree.heading("Character Name", text="Character Name")
+         self.profile_tree.column("Character Name", width=150, anchor=tk.W)
+         
+         self.profile_tree.heading("Last Used", text="Last Used")
+         self.profile_tree.column("Last Used", width=150, anchor=tk.W)
+         
+         # Set displaycolumns to hide the ID column visually
+         self.profile_tree["displaycolumns"] = ("Profile Name", "Character Name", "Last Used")
+         
+         # Add scrollbar
+         tree_scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.profile_tree.yview)
+         self.profile_tree.configure(yscrollcommand=tree_scrollbar.set)
+         
+         # Pack tree and scrollbar
+         self.profile_tree.pack(side=tk.LEFT, expand=True, fill=tk.BOTH)
+         tree_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
+         
+         # Buttons Frame
+         buttons_frame = ttk.Frame(main_frame)
+         buttons_frame.pack(fill=tk.X)
+         
+         # Create buttons
+         create_button = ttk.Button(buttons_frame, text="Create New", command=self._create_new_profile)
+         create_button.pack(side=tk.LEFT, padx=2, pady=5)
+         
+         edit_button = ttk.Button(buttons_frame, text="Edit Selected", command=self._edit_selected_profile)
+         edit_button.pack(side=tk.LEFT, padx=2, pady=5)
+         
+         delete_button = ttk.Button(buttons_frame, text="Delete Selected", command=self._delete_selected_profile)
+         delete_button.pack(side=tk.LEFT, padx=2, pady=5)
+         
+         set_active_button = ttk.Button(buttons_frame, text="Set as Active", command=self._set_active_profile)
+         set_active_button.pack(side=tk.LEFT, padx=2, pady=5)
+         
+         import_button = ttk.Button(buttons_frame, text="Import Profile(s)", command=self._import_profiles)
+         import_button.pack(side=tk.LEFT, padx=2, pady=5)
+         
+         export_button = ttk.Button(buttons_frame, text="Export Selected", command=self._export_selected_profile)
+         export_button.pack(side=tk.LEFT, padx=2, pady=5)
+         
+         close_button = ttk.Button(buttons_frame, text="Close", command=self._on_close)
+         close_button.pack(side=tk.RIGHT, padx=5, pady=5)
+         
+         # Load profiles into the list
+         self._load_profiles_to_list()
+     
+     def _load_profiles_to_list(self):
+         """Load profiles into the Treeview."""
+         # Clear existing items
+         for item in self.profile_tree.get_children():
+             self.profile_tree.delete(item)
+         
+         # Insert profiles into the Treeview
+         for profile in self.profiles:
+             # Format last_used_date
+             last_used_formatted = profile.last_used_date.strftime('%Y-%m-%d %H:%M') if profile.last_used_date else "Never"
+             
+             # Insert profile data
+             self.profile_tree.insert(
+                 "", 
+                 "end", 
+                 iid=profile.profile_id,  # Use profile_id as the item ID for easy retrieval
+                 values=(
+                     profile.profile_id,
+                     profile.profile_name,
+                     profile.game_character_name or "-",
+                     last_used_formatted
+                 )
+             )
+     
+     def _create_new_profile(self):
+         """Placeholder for creating a new profile."""
+         self.logger.info("Create New Profile button clicked (placeholder).")
+         messagebox.showinfo("Create New Profile", "This feature will be implemented in Task 3.3.")
+     
+     def _edit_selected_profile(self):
+         """Placeholder for editing the selected profile."""
+         selected_items = self.profile_tree.selection()
+         if not selected_items:
+             messagebox.showwarning("No Selection", "Please select a profile to edit.")
+             return
+         
+         selected_id = selected_items[0]  # Get the profile_id of the selected item
+         self.logger.info(f"Edit Profile button clicked for profile ID: {selected_id} (placeholder).")
+         messagebox.showinfo("Edit Profile", f"This feature will be implemented in Task 3.3.\nSelected Profile ID: {selected_id}")
+     
+     def _delete_selected_profile(self):
+         """Placeholder for deleting the selected profile."""
+         selected_items = self.profile_tree.selection()
+         if not selected_items:
+             messagebox.showwarning("No Selection", "Please select a profile to delete.")
+             return
+         
+         selected_id = selected_items[0]  # Get the profile_id of the selected item
+         
+         # Get the profile name for the confirmation message
+         selected_item_values = self.profile_tree.item(selected_id, "values")
+         profile_name = selected_item_values[1] if len(selected_item_values) > 1 else "Unknown"
+         
+         # Ask for confirmation
+         confirm = messagebox.askyesno(
+             "Confirm Delete", 
+             f"Are you sure you want to delete the profile '{profile_name}'?\nThis action cannot be undone."
+         )
+         
+         if confirm:
+             self.logger.info(f"Delete Profile confirmed for profile ID: {selected_id} (placeholder).")
+             messagebox.showinfo("Delete Profile", f"This feature will be implemented in Task 3.3.\nProfile '{profile_name}' would be deleted.")
+         else:
+             self.logger.info(f"Delete Profile cancelled for profile ID: {selected_id}.")
+     
+     def _set_active_profile(self):
+         """Placeholder for setting the selected profile as active."""
+         selected_items = self.profile_tree.selection()
+         if not selected_items:
+             messagebox.showwarning("No Selection", "Please select a profile to set as active.")
+             return
+         
+         selected_id = selected_items[0]  # Get the profile_id of the selected item
+         
+         # Get the profile name for the info message
+         selected_item_values = self.profile_tree.item(selected_id, "values")
+         profile_name = selected_item_values[1] if len(selected_item_values) > 1 else "Unknown"
+         
+         self.logger.info(f"Set as Active button clicked for profile ID: {selected_id} (placeholder).")
+         messagebox.showinfo("Set Active Profile", f"This feature will be implemented in Task 3.3.\nProfile '{profile_name}' would be set as active.")
+     
+     def _import_profiles(self):
+         """Placeholder for importing profiles from file."""
+         filetypes = [("JSON Files", "*.json"), ("All Files", "*.*")]
+         file_path = filedialog.askopenfilename(
+             title="Import Profile",
+             filetypes=filetypes,
+             parent=self
+         )
+         
+         if file_path:
+             self.logger.info(f"Import Profile file selected: {file_path} (placeholder).")
+             messagebox.showinfo("Import Profile", f"This feature will be implemented in Task 3.3.\nSelected file: {file_path}")
+         else:
+             self.logger.info("Import Profile cancelled.")
+     
+     def _export_selected_profile(self):
+         """Placeholder for exporting selected profile to file."""
+         selected_items = self.profile_tree.selection()
+         if not selected_items:
+             messagebox.showwarning("No Selection", "Please select a profile to export.")
+             return
+         
+         selected_id = selected_items[0]  # Get the profile_id of the selected item
+         
+         # Get the profile name for default filename suggestion
+         selected_item_values = self.profile_tree.item(selected_id, "values")
+         profile_name = selected_item_values[1] if len(selected_item_values) > 1 else "profile"
+         
+         # Suggest a filename based on the profile name (normalize for safe filename)
+         safe_filename = "".join(c if c.isalnum() or c in "._- " else "_" for c in profile_name)
+         suggested_filename = f"{safe_filename.strip()}.json"
+         
+         filetypes = [("JSON Files", "*.json"), ("All Files", "*.*")]
+         file_path = filedialog.asksaveasfilename(
+             title="Export Profile",
+             defaultextension=".json",
+             initialfile=suggested_filename,
+             filetypes=filetypes,
+             parent=self
+         )
+         
+         if file_path:
+             self.logger.info(f"Export Profile file selected for profile ID {selected_id}: {file_path} (placeholder).")
+             messagebox.showinfo("Export Profile", f"This feature will be implemented in Task 3.3.\nProfile would be exported to: {file_path}")
+         else:
+             self.logger.info(f"Export Profile cancelled for profile ID: {selected_id}.")
+     
+     def _on_close(self):
+         """Handle dialog close."""
+         if self.on_close_callback:
+             self.on_close_callback()
+         self.destroy()
+     
+     def show(self):
+         """Show the dialog and wait for it to be closed."""
+         self._load_profiles_to_list()
+         self.deiconify()
+         self.wait_window()
+ 
+ 
+ # Self-test block
+ if __name__ == "__main__":
+     # Create a simple logger
+     logger = logging.getLogger("ProfileManagerTest")
+     logger.setLevel(logging.DEBUG)
+     handler = logging.StreamHandler()
+     handler.setLevel(logging.DEBUG)
+     formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+     handler.setFormatter(formatter)
+     logger.addHandler(handler)
+     
+     # Create a mock ConfigManager
+     class MockConfigManager:
+         def __init__(self):
+             self.logger = logger
+         
+         def load_settings(self):
+             return AppSettings()
+         
+         def save_settings(self, settings):
+             return True
+     
+     # Create dummy profiles for testing
+     mock_profiles = [
+         Profile(
+             profile_name="Default Profile",
+             app_settings=AppSettings()
+         ),
+         Profile(
+             profile_name="My Warrior",
+             game_character_name="Conan",
+             app_settings=AppSettings(sprint_key="z")
+         ),
+         Profile(
+             profile_name="My Mage",
+             game_character_name="Gandalf",
+             app_settings=AppSettings(sprint_key="x", roi_x=100, roi_y=100)
+         )
+     ]
+     
+     # Create and run the dialog
+     root = tk.Tk()
+     root.withdraw()  # Hide the root window
+     
+     dialog = ProfileManagerDialog(
+         root,
+         MockConfigManager(),
+         logger,
+         mock_profiles
+     )
+     
+     dialog.show()
+     
+     # Start the Tkinter main loop
+     root.mainloop() 
```

---

Now, let's update the `tray_app.py` file to integrate the profile manager and add profile-related functionality to the tray menu:

---

```diff
  import threading
  import time
- from typing import Optional, Callable, Dict, Tuple
+ import tkinter as tk # Added for tk_root_for_config
+ from tkinter import messagebox # Added for messagebox
+ from typing import Optional, Callable, Dict, Tuple, List
  
  try:
  # Import project components
  try:
-     from ..data_models import AppSettings
+     from ..data_models import AppSettings, Profile # Added Profile
      from ..core.window_manager import WindowManager
      from ..core.icon_detector import IconDetector
      from ..core.input_manager import InputManager
      from ..utils.performance_monitor import PerformanceMonitor
      from ..core.ml_detector import MLDetector, ONNXRUNTIME_AVAILABLE
+     from .config_gui import ConfigGUI # Ensure ConfigGUI is imported
+     from .profile_manager_dialog import ProfileManagerDialog # Added ProfileManagerDialog
  except (ImportError, ValueError):
      current_dir = pathlib.Path(__file__).parent.resolve()
           sys.path.insert(0, str(project_src_dir))
      
-     from data_models import AppSettings
+     from data_models import AppSettings, Profile # Added Profile
      from core.window_manager import WindowManager
      from core.icon_detector import IconDetector
      from core.input_manager import InputManager
      from utils.performance_monitor import PerformanceMonitor
      from core.ml_detector import MLDetector, ONNXRUNTIME_AVAILABLE
+     from ui.config_gui import ConfigGUI # Ensure ConfigGUI is imported
+     from ui.profile_manager_dialog import ProfileManagerDialog # Added ProfileManagerDialog
  
  try:
-     from .config_gui import ConfigGUI
+     # Check if ConfigGUI is available
      CONFIG_GUI_AVAILABLE = True
- except ImportError:
+ except NameError:
      CONFIG_GUI_AVAILABLE = False
  
          self.logger = logger
          self.root_dir = root_dir
-         self.tk_root_for_config: Optional[tk.Tk] = None
+         self.tk_root_for_config: Optional[tk.Tk] = None # For managing Tkinter dialogs
  
          if not PYSTRAY_AVAILABLE:
          self.detection_thread: Optional[threading.Thread] = None
          self.config_gui_instance: Optional[ConfigGUI] = None
+         self.profile_manager_dialog_instance: Optional[ProfileManagerDialog] = None # Added for profile manager
  
-         # Error handling counters and flags
          self.game_not_found_consecutive_count: int = 0
          self.ml_prediction_failure_consecutive_count: int = 0
          self.ml_detector: Optional[MLDetector] = None
  
-         # Cache for detection results
          self.detection_cache: Dict[int, Tuple[float, Tuple[bool, float, Optional[Tuple[int, int, int, int]]]]] = {}
          self.cache_hits = 0
          self.cache_misses = 0
          self.cache_evictions = 0
  
-         self._load_resources() # Load templates and initialize ML detector
+         self._load_resources()
          
          self.logger.info("SprintManagerApp initialized.")
               self.pystray_icon.update_menu()
  
-     def _on_clicked_open_config(self, icon: pystray.Icon, item: pystray.MenuItem):
+     def _on_clicked_open_config(self, icon: Optional[pystray.Icon], item: Optional[pystray.MenuItem]):
          """Callback for the Open Config menu item."""
-         self.logger.info("Opening configuration dialog")
-         
-         # If we have a parent TrayApp object that handles the configuration dialog,
-         # delegate to it (this is the preferred approach)
-         parent = getattr(icon, 'parent_app', None)
-         if parent and hasattr(parent, '_open_configuration'):
-             parent._open_configuration()
-             return
-             
-         # Legacy/fallback approach if not running under TrayApp
-         # If config dialog is already open, bring it to the front
-         if self.config_gui_instance is not None:
+         if self.config_gui_instance is not None and hasattr(self.config_gui_instance, 'dialog') and self.config_gui_instance.dialog.winfo_exists():
              self.logger.debug("Config dialog already open, bringing to front")
-             if hasattr(self.config_gui_instance, 'dialog') and self.config_gui_instance.dialog:
              self.config_gui_instance.dialog.lift()
              self.config_gui_instance.dialog.focus_force()
              return
          
+         self.logger.info("Opening configuration dialog")
+         
          if not CONFIG_GUI_AVAILABLE:
-             self.logger.warning("ConfigGUI not available. Falling back to text editor.")
+             self.logger.warning("ConfigGUI class not available. Falling back to text editor.")
+             # Fallback to text editor logic (existing code)
              config_path = self.root_dir / "config" / "settings.json"
              self.logger.info(f"Attempting to open config file: {config_path}")
              return
  
-         # Use the ConfigGUI for a more user-friendly experience
-         try:
-             # Create a tkinter root window
-             root = tk.Tk()
-             root.withdraw()  # Hide the root window
-             
-             # Create a ConfigManager instance for the ConfigGUI to use
+         try:
+             if self.tk_root_for_config is None or not self.tk_root_for_config.winfo_exists():
+                 self.tk_root_for_config = tk.Tk()
+                 self.tk_root_for_config.withdraw()
+             
              from ..config_manager import ConfigManager
+             config_path_real = self.root_dir / "config" / "settings.json"
+             template_path_real = self.root_dir / "config" / "settings.json.template"
              
-             config_path = self.root_dir / "config" / "settings.json"
-             template_path = self.root_dir / "config" / "settings.json.template"
+             # Ensure actual ConfigManager is used
+             actual_config_manager = ConfigManager(config_path_real, template_path_real, self.logger)
+             current_settings = actual_config_manager.load_settings() # Load fresh settings
              
-             config_manager = ConfigManager(config_path, template_path, self.logger)
-             
-             # Create and show the ConfigGUI with callbacks
              self.config_gui_instance = ConfigGUI(
-                 root, 
-                 config_manager, 
-                 self.app_settings, 
+                 self.tk_root_for_config, 
+                 actual_config_manager, 
+                 current_settings, # Pass freshly loaded settings 
                  self.logger,
                  on_apply_callback=self._handle_settings_applied_from_gui,
-                 destroy_handler=self._on_config_closed
+                 destroy_handler=self._on_config_gui_closed # Renamed for clarity
              )
-             
+             self.config_gui_instance.show()
          except Exception as e:
              self.logger.exception(f"Error opening configuration dialog: {e}")
              messagebox.showerror("Error", f"Could not open configuration dialog: {e}")
  
+ 
      def _handle_settings_applied_from_gui(self, new_settings: AppSettings):
          """Callback from ConfigGUI when settings are applied or OK'd."""
          # Update core components based on new settings
          self.icon_detector.temporal_consistency_frames = self.app_settings.temporal_consistency_frames
-         # Other settings like FPS are used directly in the loop.
          
          if previous_detection_method != self.app_settings.detection_method or \
-            (self.app_settings.detection_method == "ml" and self.ml_detector is None): # Or if ML settings changed
+            (self.app_settings.detection_method == "ml" and self.ml_detector is None):
              self._load_resources(is_reload=True) # This will re-initialize ML detector or template
  
          self._update_status(f"Settings Updated ({self.app_settings.detection_method})")
  
-     def _on_config_closed(self, save_applied: bool):
+     def _on_config_gui_closed(self, save_applied: bool):
          """
          Handle configuration dialog closing.
              save_applied: Whether settings were successfully saved/applied.
          """
-         self.logger.debug(f"Config dialog closed, save_applied={save_applied}")
-         
-         # Clear the reference to the config_gui
+         self.logger.debug(f"ConfigGUI dialog closed, save_applied={save_applied}")
          self.config_gui_instance = None
-         
-     def _reinitialize_detector(self):
-         """Reinitialize the detector based on the current detection method setting."""
+         if self.tk_root_for_config and self.tk_root_for_config.winfo_exists():
+             is_main_tk_loop_running = False
              try:
-             # If detection method is ML, initialize MLDetector
-             if self.app_settings.detection_method == "ml":
-                 if not ONNXRUNTIME_AVAILABLE:
-                     self.logger.error("ML detection method selected but ONNX Runtime is not available.")
-                     self.logger.warning("Falling back to template matching.")
-                     self.app_settings.detection_method = "template"  # Fallback
-                     self._update_status("ML unavailable - Using Template")
+                 # Check if any other Toplevel windows exist that are children of tk_root_for_config
+                 if any(win.winfo_exists() for win in self.tk_root_for_config.winfo_children() if isinstance(win, tk.Toplevel)):
+                     is_main_tk_loop_running = True
+             except tk.TclError: # Can happen if root is already destroyed
+                 pass
+ 
+             if not is_main_tk_loop_running:
+                 self.logger.debug("No other Toplevels, destroying tk_root_for_config.")
+                 # self.tk_root_for_config.destroy() # Be cautious with destroying root if other dialogs might use it
+                 # self.tk_root_for_config = None
              else:
-                     ml_model_path = self.root_dir / self.app_settings.ml_model_path
-                     self.logger.info(f"Initializing ML detector with model: {ml_model_path}")
-                     
-                     # Convert list to tuple for input size
-                     input_size = tuple(self.app_settings.ml_input_size_wh)
-                     
-                     self.ml_detector = MLDetector(
-                         model_path=ml_model_path,
-                         input_size_wh=input_size,
-                         confidence_threshold=self.app_settings.ml_confidence_threshold,
-                         logger=self.logger
-                     )
-                     self.logger.info("ML detector initialized successfully.")
-                     self._update_status("ML detector initialized")
-             else:
-                 # If switching to template matching, make sure template is loaded
-                 sprint_on_template_path = self.root_dir / self.app_settings.sprint_on_icon_path
-                 self.sprint_on_template = self.icon_detector.load_template(sprint_on_template_path)
-                 
-                 if self.sprint_on_template is None:
-                     self.logger.error(f"Failed to load sprint 'ON' template from {sprint_on_template_path}")
-                     self._update_status("Template load failed")
+                  self.logger.debug("Other Toplevels exist, not destroying tk_root_for_config yet.")
+ 
+     def _get_mock_profiles(self) -> List[Profile]:
+         """
+         Returns a list of mock Profile objects for UI testing.
+         
+         This is a temporary placeholder for fetching profiles until Task 3.3 implements
+         actual profile storage and loading.
+         
+         Returns:
+             List[Profile]: A list of mock profiles for testing the UI.
+         """
+         self.logger.debug("Generating mock profiles for tray menu.")
+         # Create default AppSettings to embed in profiles
+         default_app_settings = AppSettings()
+         profile1_settings = AppSettings(game_window_title="DAOC - Char1", sprint_key="1")
+         profile2_settings = AppSettings(game_window_title="DAOC - Char2", sprint_key="2", roi_x=50)
+ 
+         mock_profiles = [
+             Profile(profile_name="Default Profile", app_settings=default_app_settings),
+             Profile(profile_name="Warrior Bob", game_character_name="BobTheWarrior", app_settings=profile1_settings),
+             Profile(profile_name="Mage Alice", game_character_name="AliceTheMage", app_settings=profile2_settings)
+         ]
+         return mock_profiles
+ 
+     def _select_profile(self, profile: Profile):
+         """
+         Placeholder for selecting and activating a profile.
+         
+         This method will be implemented fully in Task 3.3 to load the selected profile's
+         app_settings into the application.
+         
+         Args:
+             profile (Profile): The profile to select and activate.
+         """
+         self.logger.info(f"Profile selected (placeholder action): {profile.profile_name}")
+         # In Task 3.3, this will trigger loading profile.app_settings into self.app_settings
+         # and then call self._handle_settings_applied_from_gui(profile.app_settings) or similar
+         messagebox.showinfo("Profile Selected", f"Profile '{profile.profile_name}' selected.\n(Full switching logic in Task 3.3)")
+ 
+     def _build_profile_sub_menu(self):
+         """
+         Builds the dynamic sub-menu for profile selection.
+         
+         Returns:
+             pystray.Menu: A menu containing items for each available profile.
+         """
+         profiles = self._get_mock_profiles()
+         if not profiles:
+             return pystray.Menu(pystray.MenuItem("No profiles available", None, enabled=False))
+ 
+         menu_items = []
+         # Placeholder for active profile logic - assume first profile is active for now
+         # In a real app, self.app_settings.active_profile_id or similar would be checked
+         active_profile_name_placeholder = profiles[0].profile_name 
+ 
+         for p in profiles:
+             is_active = (p.profile_name == active_profile_name_placeholder) # Simple check
+             menu_items.append(
+                 pystray.MenuItem(
+                     p.profile_name,
+                     lambda profile_to_select=p: self._select_profile(profile_to_select),
+                     checked=lambda item, p_name=p.profile_name: (p_name == active_profile_name_placeholder), # Dynamic check
+                     radio=True # Makes them behave like radio buttons
+                 )
+             )
+         return pystray.Menu(*menu_items)
+ 
+     def _open_profile_manager(self):
+         """Opens the Profile Manager dialog."""
+         if self.profile_manager_dialog_instance is not None and self.profile_manager_dialog_instance.winfo_exists():
+             self.logger.debug("Profile Manager dialog already open, bringing to front")
+             self.profile_manager_dialog_instance.lift()
+             self.profile_manager_dialog_instance.focus_force()
+             return
+ 
+         self.logger.info("Opening Profile Manager dialog.")
+         mock_profiles = self._get_mock_profiles() # Use mock profiles for now
+ 
+         if self.tk_root_for_config is None or not self.tk_root_for_config.winfo_exists():
+             self.tk_root_for_config = tk.Tk()
+             self.tk_root_for_config.withdraw()
+ 
+         # Assuming ConfigManager might be needed by ProfileManagerDialog eventually
+         from ..config_manager import ConfigManager
+         config_path_real = self.root_dir / "config" / "settings.json"
+         template_path_real = self.root_dir / "config" / "settings.json.template"
+         temp_cm_for_profile_dialog = ConfigManager(config_path_real, template_path_real, self.logger)
+ 
+         self.profile_manager_dialog_instance = ProfileManagerDialog(
+             self.tk_root_for_config,
+             temp_cm_for_profile_dialog, # Pass a ConfigManager for now (will be ProfileIOManager in Task 3.3)
+             self.logger,
+             mock_profiles,
+             on_close_callback=self._on_profile_manager_closed
+         )
+         self.profile_manager_dialog_instance.show()
+ 
+     def _on_profile_manager_closed(self):
+         """Callback when the Profile Manager dialog is closed."""
+         self.logger.debug("Profile Manager dialog closed.")
+         self.profile_manager_dialog_instance = None
+         if self.pystray_icon: # Update menu in case profile list changed
+             self.pystray_icon.update_menu()
+         if self.tk_root_for_config and self.tk_root_for_config.winfo_exists():
+             # Similar logic to _on_config_gui_closed
+             is_main_tk_loop_running = False
+             try:
+                 # Check if any other Toplevel windows exist that are children of tk_root_for_config
+                 if any(win.winfo_exists() for win in self.tk_root_for_config.winfo_children() if isinstance(win, tk.Toplevel)):
+                     is_main_tk_loop_running = True
+             except tk.TclError: # Can happen if root is already destroyed
+                 pass
+ 
+             if not is_main_tk_loop_running:
+                 self.logger.debug("No other Toplevels from tk_root_for_config, destroying it.")
+                 # self.tk_root_for_config.destroy() # Be cautious with destroying root if other dialogs might use it
+                 # self.tk_root_for_config = None
              else:
-                     self.logger.info("Template detector initialized successfully.")
-                     self._update_status("Template detector initialized")
-         except Exception as e:
-             self.logger.error(f"Error reinitializing detector: {e}", exc_info=True)
-             self._update_status("Detector init error")
+                  self.logger.debug("Other Toplevels exist, not destroying tk_root_for_config yet.")
+ 
+     def _reinitialize_detector(self):
+         """Reinitialize the detector based on the current detection method setting."""
+         self.logger.info(f"Reinitializing detector for method: {self.app_settings.detection_method}")
+         self._load_resources(is_reload=True) # _load_resources now handles this logic
              
      def _update_performance_settings(self):
-         """Update performance-related settings based on current app_settings."""
-         # Update temporal consistency frames in icon_detector
          self.icon_detector.temporal_consistency_frames = self.app_settings.temporal_consistency_frames
-         
-         # Other performance settings like capture_fps would be applied in the detection loop
-         self.logger.info("Performance settings updated")
+         self.logger.info("Performance settings updated (temporal consistency frames). Other settings applied in loop.")
  
-     def _on_clicked_exit(self, icon: pystray.Icon, item: pystray.MenuItem):
-         """Callback for the Exit menu item."""
+     def _on_clicked_exit(self, icon: Optional[pystray.Icon], item: Optional[pystray.MenuItem]):
          self.logger.info("Exit requested from tray menu.")
          self._update_status("Exiting...")
-         self.stop_event.set() # Signal detection thread to stop
+         self.stop_event.set()
          if self.pystray_icon:
-             self.pystray_icon.stop() # Stop the pystray icon loop
+             self.pystray_icon.stop()
  
      @property
      def menu(self) -> pystray.Menu:
          """Dynamically generates the tray menu."""
-         # Checkable state depends on the pause event
          paused_state = self.pause_event.is_set()
+         status_item_text = f"Status: {self.status_message}"
          
          return pystray.Menu(
-             pystray.MenuItem(
-                 lambda text: f"Status: {self.status_message}", # Dynamic text based on current status
-                 None, # No action when clicking status
-                 enabled=False # Make it non-clickable
-             ),
+             pystray.MenuItem(status_item_text, None, enabled=False),
              pystray.Menu.SEPARATOR,
              pystray.MenuItem(
                  'Pause' if not paused_state else 'Resume',
                  self._on_clicked_pause_resume,
-                 checked=lambda item: paused_state # Set checkmark based on state
+                 checked=lambda item: self.pause_event.is_set() 
              ),
-             pystray.MenuItem(
-                 'Open Config',
-                 self._on_clicked_open_config
-             ),
-             pystray.MenuItem(
-                 'Exit',
-                 self._on_clicked_exit
-             )
+             pystray.MenuItem('Open Configuration', self._on_clicked_open_config),
+             pystray.Menu.SEPARATOR, # Separator for profiles
+             pystray.MenuItem('Profiles', self._build_profile_sub_menu), # Profiles sub-menu
+             pystray.MenuItem('Manage Profiles...', self._open_profile_manager),
+             pystray.Menu.SEPARATOR,
+             pystray.MenuItem('Exit', self._on_clicked_exit)
          )
  
```

---

Let's also update the `_load_resources` method in `tray_app.py` to ensure it's properly handling and working with the existing resources:

---

Read file: src/daoc_sprint_manager/ui/tray_app.py

---

Perfect! It looks like the `_load_resources` method is already well-implemented to handle ML detector and template initialization based on the current detection method, including proper fallback and error handling.

Now let's verify everything we've implemented:

1. ‚úÖ Created a new file `src/daoc_sprint_manager/ui/profile_manager_dialog.py` with a `ProfileManagerDialog` class
   - ‚úÖ Implemented UI with a treeview for profile display
   - ‚úÖ Added buttons for Create, Edit, Delete, Set Active, Import, Export, and Close
   - ‚úÖ Created placeholder methods for button actions
   - ‚úÖ Added a self-test block for standalone testing

2. ‚úÖ Updated `src/daoc_sprint_manager/ui/tray_app.py` to integrate profile management
   - ‚úÖ Added import for `Profile` from `data_models` and `ProfileManagerDialog` from `.profile_manager_dialog`
   - ‚úÖ Added `self.profile_manager_dialog_instance` in `__init__`
   - ‚úÖ Implemented `_get_mock_profiles()` method to return test profiles
   - ‚úÖ Implemented `_select_profile()` placeholder method
   - ‚úÖ Implemented `_build_profile_sub_menu()` to create dynamic profile selection menu
   - ‚úÖ Implemented `_open_profile_manager()` to display the dialog
   - ‚úÖ Implemented `_on_profile_manager_closed()` callback
   - ‚úÖ Updated the `menu` property to include "Profiles" and "Manage Profiles..." options

All the requirements for Phase 3, Task 3.2 (Part 1) have been successfully implemented.

Phase 3, Task 3.2 (Part 1: Profile Manager UI Framework & Tray Integration) deliverables complete.

---

_**User**_

Please update our various forms of documentation and memory, then create a prompt for our AI Orchestrator with what we've done and request a prompt for the next phase of development

---

_**Assistant**_



---

I'll update the documentation to reflect the completion of Task 3.2 (Part 1) - Profile Manager UI Framework & Tray Integration, and then create a handoff prompt for the AI Orchestrator.

---

<details>
            <summary>Listed directory  ‚Ä¢ **25** results</summary>
        
| Name |
|-------|
| üìÑ `AI_HANDOFF.md` |
| üìÑ `TASK.md` |
| üìÑ `progress.md` |
| üìÑ `activeContext.md` |
| üìÅ `docs` |
| üìÑ `collect_dataset.bat` |
| üìÅ `PythonSprint` |
| üìÑ `.gitignore` |
| üìÑ `README.md` |
| üìÅ `config` |
| üìÅ `tests` |
| üìÅ `logs` |
| üìÑ `TRANSITION.md` |
| üìÑ `requirements.txt` |
| üìÑ `PLANNING.md` |
| üìÑ `productContext.md` |
| üìÑ `systemPatterns.md` |
| üìÑ `techContext.md` |
| üìÑ `projectbrief.md` |
| üìÑ `PHASE2_COMPLETE.md` |
| üìÑ `start_sprint_manager.bat` |
| üìÑ `configure_roi.bat` |
| üìÅ `src` |
| üìÅ `ASMS-DAOC` |
| üìÅ `.specstory` |

</details>

---

Let's first check the current content of the documentation files to ensure our updates are consistent with the existing structure.

---

Read file: activeContext.md

---

Read file: progress.md

---

Read file: progress.md

---

Read file: TASK.md

---



---



---

