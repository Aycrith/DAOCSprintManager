<!-- Generated by SpecStory -->

# Error Handling and Fallbacks Implementation (2025-05-10 15:17:40)

_**User**_

# PyDAOC Sprint Manager - Coder Task: Phase 3, Step 3 - Error Handling & Fallbacks

## Project Overview & Your Role
You are the **Coder AI** for the "DAOC Sprint Manager" project, orchestrated by Gemini 2.5 Pro. This Python application automates sprint buff management in Dark Age of Camelot. The core functionality and Configuration GUI implementation are complete.

- **Phase 1 & 2**: COMPLETE.
- **Phase 3, Step 1 (ML Detection Integration)**: COMPLETE.
- **Phase 3, Step 2 (Configuration GUI)**: COMPLETE (Tasks 1.1-1.5).

## Current Project Status
The application can detect the game window, capture ROI, use template matching OR ML for icon detection (with fallbacks for ML initialization), simulate input, and provides a Config GUI via the tray menu.

## Your Current Task: Phase 3, Step 3 - Comprehensive Error Handling & Fallbacks

Your task is to enhance the application's stability and resilience by implementing comprehensive error handling and fallback mechanisms within the main detection loop (`SprintManagerApp.run_detection_logic`).

**File to Modify:** `src/daoc_sprint_manager/ui/tray_app.py` (Primarily, within the `SprintManagerApp` class)

## Detailed Requirements

1.  **Game Window Detection Failures**:
    *   **Implement Counter**: Add an instance variable to `SprintManagerApp`, e.g., `self.game_not_found_consecutive_count: int = 0`.
    *   **Increment Counter**: In `run_detection_logic`, inside the `if game_window is None:` block, increment this counter.
    *   **Reset Counter**: In `run_detection_logic`, after successfully finding the game window (`if game_window is not None:`), reset the counter: `self.game_not_found_consecutive_count = 0`.
    *   **Implement Pause Logic**: Inside the `if game_window is None:` block, add a check: `if self.game_not_found_consecutive_count >= self.app_settings.game_not_found_retry_delay_s:`. *Note: The setting `game_not_found_retry_delay_s` is currently used for sleep duration, but its name implies it could double as a retry threshold count.* Alternatively, add a new setting `game_not_found_max_retries: int`. Let's use a new hardcoded threshold for now, e.g., 3 attempts. `if self.game_not_found_consecutive_count >= 3:`.
    *   **Auto-Pause**: If the consecutive count meets the threshold:
        *   Set the pause event: `self.pause_event.set()`.
        *   Update status: `self._update_status("Game Not Found - Auto-Paused")`.
        *   Log the auto-pause event.
    *   **Auto-Resume Logic**: In `run_detection_logic`, when a game window is found AFTER being auto-paused (check `if self.pause_event.is_set()` and `self.game_not_found_consecutive_count == 0` after finding the window), clear the pause event: `self.pause_event.clear()`, update status: `self._update_status(f"Game Found - Resuming ({self.app_settings.detection_method})")`, and log the auto-resume event.

2.  **ML Prediction Failure Detection**:
    *   **Implement Counter**: Add an instance variable, e.g., `self.ml_prediction_failure_consecutive_count: int = 0`.
    *   **Increment Counter**: In `run_detection_logic`, inside the `self.app_settings.detection_method == "ml"` block, if `ml_detector.predict()` raises an exception OR returns `(False, 0.0)` consistently (this might need refinement, but for now increment on *any* exception from predict): `self.ml_prediction_failure_consecutive_count += 1`.
    *   **Reset Counter**: In `run_detection_logic`, inside the `self.app_settings.detection_method == "ml"` block, if `ml_detector.predict()` completes successfully (no exception, and potentially `score > 0.0`), reset the counter: `self.ml_prediction_failure_consecutive_count = 0`.
    *   **Implement Fallback Logic**: After attempting ML prediction and incrementing the failure counter: `if self.ml_prediction_failure_consecutive_count >= 5:`.
    *   **Temporary Fallback**: If the consecutive failure count meets the threshold (e.g., 5 consecutive):
        *   Log the fallback event.
        *   Temporarily switch the detection method for the *current loop iteration*: Set a flag or variable that signals to use template matching for this loop cycle. For robustness, maybe change `self.app_settings.detection_method = "template"` *in memory* for the rest of the session. Log this change.
        *   Update status: `self._update_status("ML Prediction Error - Using Template")`.
        *   Reset the ML failure counter after triggering fallback.

3.  **Resource Loading Refinements**:
    *   **Reload Error Handling**: In `_load_resources` (which is called by `_handle_settings_applied_from_gui`):
        *   Modify the `if template_load_failed and self.app_settings.detection_method == "template":` block. If this occurs *during a reload* (`if is_reload:`), do NOT exit the application (`sys.exit`). Instead, log a CRITICAL error, update status, and ideally reset the detection method to a safe state if possible (e.g., back to template matching, even though the template failed, or a dedicated "Error State" method). Log that the template load failure occurred during reload and the app did not exit.
        *   Handle ML initialization errors (`FileNotFoundError`, `ValueError`, general `Exception`) similarly during reload (`if is_reload:`). Log the specific error details, update status, and fall back to template matching *in memory* (`self.app_settings.detection_method = "template"`). Do NOT exit the app.
        *   Ensure status messages clearly reflect *which* resource loading failed during reload (e.g., "Template Reload Error", "ML Model Reload Error").

## Code Quality & Standards
- Adhere to all project standards (PEP 8, type hints, docstrings, `pathlib`).
- Use clear variable names for counters and flags.
- Add informative log messages at each step of the error handling and fallback logic.
- Ensure the code is placed within the `SprintManagerApp` class, likely in `run_detection_logic` and `_load_resources`.

## Expected Deliverable
- The complete, updated content for `src/daoc_sprint_manager/ui/tray_app.py`.

## Handoff Instruction for Coder AI (Upon Completion of Phase 3, Step 3):
**After completing all deliverables for this specific task (Phase 3, Step 3), you MUST provide a new handoff prompt intended for the Orchestrator AI (Gemini 2.5 Pro). This prompt should:**
1.  **Confirm Completion**: State "Phase 3, Step 3 (Comprehensive Error Handling & Fallbacks) deliverables complete."
2.  **Summarize Work Done**: Briefly list the key achievements regarding error handling and fallbacks.
3.  **Identify Key Files Modified**: List `src/daoc_sprint_manager/ui/tray_app.py`.
4.  **State Readiness for Next Task**: Indicate the project is ready for the next task in Phase 3.
5.  **Request Orchestrator Action**: Ask the Orchestrator AI to:
    *   Review the completed Phase 3, Step 3 implementation.
    *   Update project meta-documentation (`TASK.md`, `progress.md`, `activeContext.md`).
    *   Prepare and provide the detailed Coder AI prompt for the next task.

---

_**Assistant**_



---

Let me first examine the current implementation of the SprintManagerApp class and the detection logic to understand what needs to be modified.

---

Read file: src/daoc_sprint_manager/ui/tray_app.py

---

Let me read the rest of the file, specifically focusing on the run_detection_logic method and _load_resources method which need to be modified.

---

Read file: src/daoc_sprint_manager/ui/tray_app.py

---

Let me read the rest of the file to get the complete implementation of the _load_resources method:

---

Read file: src/daoc_sprint_manager/ui/tray_app.py

---

Now that I have a good understanding of the current code, I will implement the required error handling and fallback mechanisms. I'll update the `tray_app.py` file with the necessary changes:

---

```diff
          self.detection_thread: Optional[threading.Thread] = None
          self.config_gui_instance: Optional[ConfigGUI] = None
+         
+         # Error handling counters and flags
+         self.game_not_found_consecutive_count: int = 0
+         self.ml_prediction_failure_consecutive_count: int = 0
+         self.was_auto_paused_due_to_game_not_found: bool = False
          
          self.perf_monitor = PerformanceMonitor(self.logger)
  
              if game_window is None:
+                 # Game window not found - increment counter and check for auto-pause
+                 self.game_not_found_consecutive_count += 1
+                 self.logger.debug(f"Game window not found. Consecutive count: {self.game_not_found_consecutive_count}")
+                 
+                 # Check if we should auto-pause after reaching threshold
+                 if self.game_not_found_consecutive_count >= 3:  # Hardcoded threshold for now
+                     if not self.pause_event.is_set():
+                         self.pause_event.set()
+                         self.was_auto_paused_due_to_game_not_found = True
+                         self._update_status("Game Not Found - Auto-Paused")
+                         self.logger.warning(f"Game window not found for {self.game_not_found_consecutive_count} consecutive attempts. Auto-pausing.")
+                     else:
+                         self._update_status("Game Not Found - Paused")
+                 else:
                      self._update_status("Game Not Found")
+                 
                  if self.sprint_key_physical_state:
                       try:
                       except Exception as release_err:
                           self.logger.error(f"Error releasing key (Game window lost): {release_err}")
+                 
                  self.perf_monitor.stop_timer("full_cycle")
                  self.stop_event.wait(timeout=self.app_settings.game_not_found_retry_delay_s)
                  continue
+             else:
+                 # Game window found - reset counter and check for auto-resume
+                 if self.game_not_found_consecutive_count > 0:
+                     self.logger.debug(f"Game window found after {self.game_not_found_consecutive_count} consecutive misses.")
+                     self.game_not_found_consecutive_count = 0
+                     
+                     # Auto-resume if we were auto-paused due to game window not found
+                     if self.pause_event.is_set() and self.was_auto_paused_due_to_game_not_found:
+                         self.pause_event.clear()
+                         self.was_auto_paused_due_to_game_not_found = False
+                         self._update_status(f"Game Found - Resuming ({self.app_settings.detection_method})")
+                         self.logger.info("Game window found. Auto-resuming detection.")
  
              self.perf_monitor.start_timer("roi_capture")
              loc_rect = None
              
-             if self.app_settings.detection_method == "ml" and self.ml_detector:
+             # Store original detection method for potential temporary fallback
+             current_detection_method = self.app_settings.detection_method
+             
+             if current_detection_method == "ml" and self.ml_detector:
                  try:
                      raw_found, score = self.ml_detector.predict(frame)
-                     # loc_rect remains None for ML detection
+                     # ML prediction succeeded - reset failure counter
+                     if self.ml_prediction_failure_consecutive_count > 0:
+                         self.logger.debug(f"ML prediction succeeded after {self.ml_prediction_failure_consecutive_count} consecutive failures.")
+                         self.ml_prediction_failure_consecutive_count = 0
                  except Exception as ml_err:
-                     self.logger.error(f"Error during ML prediction: {ml_err}. Defaulting to no detection for this frame.")
+                     # ML prediction failed - increment counter and check for fallback
+                     self.ml_prediction_failure_consecutive_count += 1
+                     self.logger.error(f"Error during ML prediction: {ml_err}. Consecutive failures: {self.ml_prediction_failure_consecutive_count}")
                      raw_found, score = False, 0.0
+                     
+                     # Check if we should fall back to template matching
+                     if self.ml_prediction_failure_consecutive_count >= 5:  # Threshold for fallback
+                         self.logger.warning(f"ML prediction failed {self.ml_prediction_failure_consecutive_count} consecutive times. Falling back to template matching.")
+                         self._update_status("ML Prediction Error - Using Template")
+                         
+                         # Fall back to template matching for the rest of the session
+                         self.app_settings.detection_method = "template"
+                         self.ml_prediction_failure_consecutive_count = 0  # Reset counter after triggering fallback
+                         
+                         # Try template matching for this frame
+                         if self.sprint_on_template is not None:
+                             raw_found, score, loc_rect = self.icon_detector.detect_icon(
+                                 frame, self.sprint_on_template, self.app_settings.template_match_threshold
+                             )
              else: # Template matching (either selected or as fallback)
                  if self.sprint_on_template is not None:
              confirmed_icon_is_active = self.icon_detector.update_consistent_detection_state(raw_found)
              
+             # Update logs to include both original and current detection method if they differ
+             if current_detection_method != self.app_settings.detection_method:
+                 self.logger.debug(f"Detection Frame: Method={current_detection_method}->{self.app_settings.detection_method}, RawFound={raw_found}, Score={score:.2f}, ConfirmedState={confirmed_icon_is_active}")
+             else:
                  self.logger.debug(f"Detection Frame: Method={self.app_settings.detection_method}, RawFound={raw_found}, Score={score:.2f}, ConfirmedState={confirmed_icon_is_active}")
  
              self.logger.critical(f"Failed to load sprint 'ON' template from {sprint_on_template_path} and template detection is active. Application cannot start reliably.")
              self._update_status("Error - Template Missing")
-             if not is_reload: # Only exit if it's initial load
+             if not is_reload: 
+                 # Only exit if it's initial load
                  sys.exit(1)
+             else:
+                 # During reload, don't exit - log a critical error and try to recover
+                 self.logger.critical("Template load failure during reload. The application may not function correctly.")
+                 self._update_status("Template Reload Error")
+                 # If we're already using template matching, we're in a bad state
+                 # but we'll let the app continue running and wait for the user to fix it
          elif template_load_failed:
              self.logger.warning(f"Sprint 'ON' template failed to load from {sprint_on_template_path}, but current method is '{self.app_settings.detection_method}'.")
                      self._update_status("ML Model Not Found - Using Template")
                      self.ml_detector = None
+                     
+                     # Don't exit if this happens during reload
+                     if is_reload:
+                         self.logger.critical("ML model file not found during reload. Fallback to template matching.")
+                         self._update_status("ML Model Reload Error - Using Template")
                  except ValueError as e:
                      self.logger.error(f"Error initializing ML detector: {e}")
                      self._update_status("ML Init Error - Using Template")
                      self.ml_detector = None
+                     
+                     # Don't exit if this happens during reload
+                     if is_reload:
+                         self.logger.critical(f"ML detector initialization error during reload: {e}")
+                         self._update_status("ML Init Reload Error - Using Template")
                  except Exception as e:
                      self.logger.error(f"Unexpected error initializing ML detector: {e}", exc_info=True)
                      self._update_status("ML Error - Using Template")
                      self.ml_detector = None
+                     
+                     # Don't exit if this happens during reload
+                     if is_reload:
+                         self.logger.critical(f"Unexpected ML detector error during reload: {e}")
+                         self._update_status("ML Reload Error - Using Template")
          else: # Not 'ml' or fallback occurred
              if self.ml_detector is not None:
```

---

Great! I've successfully implemented the comprehensive error handling and fallback mechanisms for the DAOC Sprint Manager application. Let me summarize the changes made:

1. **Game Window Detection Failures Handling**:
   - Added instance variables to track consecutive game window detection failures
   - Implemented auto-pause logic when the game window isn't found for 3 consecutive attempts
   - Added auto-resume functionality when the game window is found again after being auto-paused
   - Added detailed logging for all these scenarios

2. **ML Prediction Failure Detection and Fallback**:
   - Added a counter to track consecutive ML prediction failures
   - Implemented fallback to template matching after 5 consecutive ML prediction failures
   - Ensured proper logging of detection method transitions
   - Reset failure counters appropriately when operations succeed

3. **Resource Loading Error Handling**:
   - Enhanced the `_load_resources` method to handle failures differently during reloads
   - Prevented application exit on resource loading failures during reloads
   - Added specific status messages to clearly indicate which resource failed to load
   - Implemented fallback to template matching when ML resources fail to load during a reload

All changes maintain the existing error handling structure while adding more robustness and resilience to the application.

## Handoff for Orchestrator AI (Gemini 2.5 Pro):

Phase 3, Step 3 (Comprehensive Error Handling & Fallbacks) deliverables complete.

I've implemented robust error handling for the DAOC Sprint Manager with three key enhancements:
1. Auto-pause/resume functionality based on game window detection failures
2. ML detection failure tracking with automatic fallback to template matching
3. Non-fatal resource loading error handling during settings reloads

The primary file modified was `src/daoc_sprint_manager/ui/tray_app.py`, enhancing the SprintManagerApp class to include fault-tolerant operation with clear status messages and logging.

The project is now ready for the next task in Phase 3. Please review the completed implementation, update the project meta-documentation (`TASK.md`, `progress.md`, `activeContext.md`), and provide the detailed prompt for the next task in this phase.

---

_**User**_

Please stop asking it to update the documentation. Please update the meta-docummmentation first, then create the prompt for the orchestrator

---

_**Assistant**_



---

I'll update the meta-documentation and create a prompt for the Orchestrator AI.

---

Read file: TASK.md

---

Read file: progress.md

---

Read file: activeContext.md

---

Now I'll update these meta-documentation files:

---

```diff
    - [x] Update status messages to show active detection method
  
- - [ ] **Task 2.3: Error Handling & Fallback Enhancements** (Current Task)
-   - [ ] Implement counter for consecutive game window detection failures
-   - [ ] Add automatic pause/resume for game window detection
-   - [ ] Add ML prediction failure detection with automatic fallback
-   - [ ] Improve resource loading error messaging and recovery options
+ - [x] **Task 2.3: Error Handling & Fallback Enhancements**
+   - [x] Implement counter for consecutive game window detection failures
+   - [x] Add automatic pause/resume for game window detection
+   - [x] Add ML prediction failure detection with automatic fallback
+   - [x] Improve resource loading error messaging and recovery options
  
  - [ ] **Task 2.4: Dataset Collection Utility**
```

---

```diff
  - ✅ ML-Based Detection
    - ✅ Task 2.1: ONNX Integration (Implementation of MLDetector class)
-   - ✅ Step 2 (cont.): Integration of ML Detector into SprintManagerApp
+   - ✅ Task 2.2: ML Detector Integration into SprintManagerApp
      - ✅ Conditional initialization based on detection_method setting
      - ✅ Error handling for ML model loading with fallback to template matching
      - ✅ Integrated ML prediction in run_detection_logic
      - ✅ Proper reinitialization of detection resources when settings change
+   - ✅ Task 2.3: Error Handling & Fallback Enhancements
+     - ✅ Added counter for consecutive game window detection failures
+     - ✅ Implemented auto-pause/resume when game window is lost/found
+     - ✅ Added ML prediction failure tracking with automatic fallback to template matching
+     - ✅ Enhanced resource loading with specific error messages and non-fatal handling during reloads
  
  ## Current Focus
- - ⏳ Phase 3, Step 3: Comprehensive Error Handling & Fallbacks
-   - Adding counters for game window detection failures
-   - Implementing ML prediction failure detection with fallback
-   - Refining resource loading error messaging and recovery
+ - ⏳ Phase 3, Task 2.4: Dataset Collection Utility
+   - Creating tool to capture icon images in different states
+   - Implementing dataset labeling interface
  
  ## Upcoming Work
```

---

```diff
  # DAOC Sprint Manager - Active Context
  
- ## Current Focus: Configuration GUI Implementation
- 
- The active development is now focused on implementing the Configuration GUI for the DAOC Sprint Manager. This is the highest priority task of Phase 3, which aims to improve the user experience of the application.
+ ## Current Focus: Dataset Collection Utility (Phase 3, Task 2.4)
+ 
+ The project has successfully completed:
+ - Configuration GUI implementation (Tasks 1.1-1.5), allowing users to manage all settings through a Tkinter interface launched from the system tray.
+ - ML Detector integration into the SprintManagerApp (Phase 3, Task 2.2).
+ - Comprehensive Error Handling & Fallbacks (Phase 3, Task 2.3).
+ 
+ The error handling enhancements have significantly improved application stability by:
+ 1. Adding counters for consecutive game window detection failures with automatic pause/resume
+ 2. Implementing ML prediction failure detection with automatic fallback to template matching
+ 3. Refining resource loading for better error messaging and recovery options without application crashes
+ 
+ The immediate next focus is **Phase 3, Task 2.4: Dataset Collection Utility**, which will provide tools for:
+ 1. Capturing icon images in different states for ML model training
+ 2. Implementing a dataset labeling interface for easy annotation
+ 3. Adding image augmentation capabilities to increase training dataset variety
+ 4. Creating export functionality for training with external ML tools
+ 
+ ## Architectural Decisions
+ 
+ - Detection method fallbacks are handled in memory only (for the current session)
+ - Status messages include the active detection method for better user feedback
+ - The ML detector initialization has comprehensive error handling with specific error messages
+ - ML model paths and input sizes are configured through the Configuration GUI
+ - The application now gracefully handles failures with auto-pause and auto-resume capabilities
+ - Resource loading failures during settings changes are non-fatal and properly communicated to users
  
  ## Completed Phase 3 Components
```

---

Now I'll craft a handoff prompt for the Orchestrator AI:

## Handoff for Orchestrator AI (Gemini 2.5 Pro):

Phase 3, Step 3 (Comprehensive Error Handling & Fallbacks) deliverables complete.

I've implemented robust error handling for the DAOC Sprint Manager application with three key enhancements:
1. Auto-pause/resume functionality based on game window detection failures
2. ML detection failure tracking with automatic fallback to template matching
3. Non-fatal resource loading error handling during settings reloads

The primary file modified was `src/daoc_sprint_manager/ui/tray_app.py`, enhancing the SprintManagerApp class with fault-tolerant operation.

The meta-documentation has been updated to reflect these completed changes:
- TASK.md: Task 2.3 marked as complete
- progress.md: Added detailed completion notes for Task 2.3
- activeContext.md: Updated to focus on the next task (Dataset Collection Utility)

Ready for your assessment of the implementation and preparation of the detailed prompt for Phase 3, Task 2.4: Dataset Collection Utility.

---

_**User**_

Please create a prompt for this task of updating all of our documentation with the work accomplished then creating a prompt for the orchestrator after all of our documentation and local memory banks are updated. This way I can use this prompt next time so you understand this properlyy

---

_**Assistant**_



---

# Cursor AI Documentation Update & Orchestrator Handoff Template

## Step 1: Read Current Documentation

```
Examine the current state of documentation files to understand the work accomplished and what needs to be updated:

1. TASK.md - Check which task needs to be marked as complete
2. progress.md - Review the current progress tracking
3. activeContext.md - Understand the current focus and what's changing
```

## Step 2: Update TASK.md

```
Update TASK.md to mark the completed task(s):
- Change [ ] to [x] for the completed task
- Update any subtasks from [ ] to [x]
- Remove any "(Current Task)" designation as appropriate
```

## Step 3: Update progress.md

```
Update progress.md with details about the completed work:
- Add the completed task under the "Completed Work" section
- Include detailed bullet points about what was implemented
- Update the "Current Focus" section to point to the next task
- If applicable, update the "Overall Progress" percentage
```

## Step 4: Update activeContext.md

```
Update activeContext.md to reflect the shift in focus:
- Change the "Current Focus" heading to show the next task
- Add the completed work to the "Completed Components" section
- Update the "Architectural Decisions" with any new decisions made
- Remove outdated information that no longer applies
```

## Step 5: Create Orchestrator Handoff

```
After all documentation is updated, create a concise handoff for the Orchestrator AI that includes:

1. Confirmation: "Phase X, Task Y completed."
2. Summary: Brief overview of what was accomplished
3. Files Modified: List of the key files that were changed
4. Next Steps: Clear indication of what's next in the project
```

## Step 6: Final Check

```
Verify all documentation updates are consistent with each other:
- Task descriptions match across all files
- The next focus is clearly identified
- All architectural decisions are properly documented
```

## Example Usage:

When you need to update documentation and create a handoff after completing a task, copy this prompt and add:

"Please update project documentation for the completion of [Task X.Y: Task Name] and prepare a handoff for the Orchestrator AI. The task involved [brief description of completed work]."

---



---

