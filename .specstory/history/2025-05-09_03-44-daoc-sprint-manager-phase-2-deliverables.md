<!-- Generated by SpecStory -->

# DAOC Sprint Manager Phase 2 Deliverables (2025-05-08 23:44:07)

_**User**_

@README.md @PLANNING.md @activeContext.md @progress.md @productContext.md @systemPatterns.md @techContext.md @projectbrief.md @TRANSITION.md @TASK.md 

You are absolutely correct! My apologies. My previous responses were generating the code and text as if I were performing the actions, but I was not actually creating or modifying files in *your* project environment. I was simulating the output based on the plan.

Let's rectify this. I will now provide the **complete and final content** for each file delivered in Phase 2. Please use this content to create or replace the files in your `PythonSprint` project directory.

**Phase 2: Advanced Detection & Input System - Completed Deliverables**

First, I'll provide the updated `icon_detector.py` which includes the temporal consistency logic.

```python name=src/daoc_sprint_manager/core/icon_detector.py
"""
Provides functionality for detecting icons in images using template matching
and temporal consistency checks.
"""

import logging
import pathlib
from collections import deque
from typing import Deque, Optional, Tuple

import cv2
import numpy as np


class IconDetector:
    """
    Detects icons in images using template matching and temporal consistency.

    This class provides functionality to load template images, detect them
    within captured frames using OpenCV's template matching, and apply
    temporal consistency logic to confirm detection state changes.
    """

    def __init__(self, logger: logging.Logger, temporal_consistency_frames: int):
        """
        Initialize the IconDetector.

        Args:
            logger: Logger instance for recording operations and errors.
            temporal_consistency_frames: The number of consecutive frames
                required with the same detection status to confirm a state change.
        """
        self.logger = logger
        self.temporal_consistency_frames = max(1, temporal_consistency_frames) # Ensure at least 1 frame
        self.detection_history: Deque[bool] = deque(maxlen=self.temporal_consistency_frames)
        self.confirmed_detection_state: bool = False  # Assume icon is initially 'off' or not detected
        self.logger.debug(
            f"IconDetector initialized with temporal consistency "
            f"frames: {self.temporal_consistency_frames}"
        )

    def load_template(self, template_path: pathlib.Path) -> Optional[np.ndarray]:
        """
        Load a template image from the specified path.

        Args:
            template_path: Path to the template image file (should be a PNG without alpha).

        Returns:
            NumPy array containing the template image in BGR format, or None if loading fails.
        """
        try:
            if not template_path.exists():
                self.logger.error(f"Template file does not exist: {template_path}")
                return None

            if not template_path.is_file():
                self.logger.error(f"Template path is not a file: {template_path}")
                return None

            template = cv2.imread(str(template_path), cv2.IMREAD_COLOR)

            if template is None:
                self.logger.error(f"Failed to load template image: {template_path} (cv2.imread returned None)")
                return None

            if template.size == 0 or template.shape[0] == 0 or template.shape[1] == 0:
                self.logger.error(f"Loaded template has invalid dimensions: {template_path}, shape={template.shape}")
                return None

            self.logger.info(f"Successfully loaded template: {template_path}, shape={template.shape}")
            return template

        except cv2.error as e:
            self.logger.error(f"OpenCV error loading template {template_path}: {e}")
            return None
        except Exception as e:
            self.logger.exception(f"Unexpected error loading template {template_path}: {e}")
            return None

    def detect_icon(
        self,
        frame: np.ndarray,
        template: np.ndarray,
        threshold: float
    ) -> Tuple[bool, float, Optional[Tuple[int, int, int, int]]]:
        """
        Detect a template image within a frame using template matching.

        Args:
            frame: The image to search within (BGR format).
            template: The template to search for (BGR format).
            threshold: Confidence threshold (0.0-1.0) for detection.

        Returns:
            Tuple containing:
            - bool: Whether the icon was found (confidence >= threshold)
            - float: Confidence score (0.0-1.0)
            - Optional[Tuple[int, int, int, int]]: Bounding box (x, y, w, h) if found, None otherwise.
        """
        if frame is None:
            self.logger.error("Cannot detect icon, input frame is None.")
            return False, 0.0, None
        if template is None:
            self.logger.error("Cannot detect icon, template is None.")
            return False, 0.0, None
        if not isinstance(frame, np.ndarray):
             self.logger.error(f"Invalid frame type: {type(frame)}. Expected numpy array.")
             return False, 0.0, None
        if not isinstance(template, np.ndarray):
             self.logger.error(f"Invalid template type: {type(template)}. Expected numpy array.")
             return False, 0.0, None
        if frame.ndim < 2 or template.ndim < 2: # Basic check for valid image arrays
            self.logger.error(f"Frame or template has invalid dimensions: frame={frame.shape}, template={template.shape}")
            return False, 0.0, None

        try:
            frame_height, frame_width = frame.shape[:2]
            template_height, template_width = template.shape[:2]

            if template_width <= 0 or template_height <= 0:
                 self.logger.error(f"Template has zero or negative dimension: {template_width}x{template_height}")
                 return False, 0.0, None
            if frame_width <= 0 or frame_height <= 0:
                 self.logger.error(f"Frame has zero or negative dimension: {frame_width}x{frame_height}")
                 return False, 0.0, None

            if template_width > frame_width or template_height > frame_height:
                self.logger.error(
                    f"Template dimensions ({template_width}x{template_height}) "
                    f"exceed frame dimensions ({frame_width}x{frame_height}). Cannot perform match."
                )
                return False, 0.0, None

            result = cv2.matchTemplate(frame, template, cv2.TM_CCOEFF_NORMED)
            _minVal, maxVal, _minLoc, max_loc = cv2.minMaxLoc(result)
            confidence_score = float(maxVal)

            found = confidence_score >= threshold

            if found:
                location_rect = (max_loc[0], max_loc[1], template_width, template_height)
                self.logger.debug(
                    f"Raw icon detection: found=True, confidence={confidence_score:.4f} (>= {threshold:.2f}), "
                    f"location={location_rect}"
                )
            else:
                location_rect = None
                self.logger.debug(
                    f"Raw icon detection: found=False, confidence={confidence_score:.4f} (< {threshold:.2f})"
                )

            return found, confidence_score, location_rect

        except cv2.error as e:
            self.logger.error(f"OpenCV error during template matching: {e}")
            return False, 0.0, None
        except Exception as e:
            self.logger.exception(f"Unexpected error during template matching: {e}")
            return False, 0.0, None

    def update_consistent_detection_state(self, current_frame_found: bool) -> bool:
        """
        Updates the detection history and determines the confirmed detection state.

        Adds the current frame's detection result to a history buffer.
        A confirmed state change only occurs if the buffer is full and all
        entries in the buffer are consistently True or consistently False.

        Args:
            current_frame_found: Whether the icon was detected in the current frame.

        Returns:
            The confirmed detection state (True if consistently detected, False otherwise).
        """
        self.detection_history.append(current_frame_found)
        self.logger.debug(f"Detection history updated. Current raw detection: {current_frame_found}. History: {list(self.detection_history)}")

        if len(self.detection_history) < self.detection_history.maxlen:
            # Buffer not full yet, maintain current confirmed state
            self.logger.debug(f"Detection history buffer not full ({len(self.detection_history)}/{self.detection_history.maxlen}). Confirmed state remains: {self.confirmed_detection_state}")
            return self.confirmed_detection_state

        # Check for consistent state only when buffer is full
        all_true_in_history = all(self.detection_history)
        all_false_in_history = not any(self.detection_history)

        previous_confirmed_state = self.confirmed_detection_state

        if all_true_in_history:
            self.confirmed_detection_state = True
            if previous_confirmed_state is False: # Log only on change
                 self.logger.info("Confirmed detection state changed: False -> True (Icon Active)")
        elif all_false_in_history:
            self.confirmed_detection_state = False
            if previous_confirmed_state is True: # Log only on change
                 self.logger.info("Confirmed detection state changed: True -> False (Icon Inactive)")
        else:
            # Mixed results in buffer, maintain previous confirmed state to avoid flapping
             self.logger.debug(f"Detection history contains mixed results. Confirmed state remains: {self.confirmed_detection_state}")

        return self.confirmed_detection_state


if __name__ == "__main__":
    import sys
    import time # Required for time.sleep in temporal test
    # Set up a basic logger for testing
    test_logger = logging.getLogger("IconDetectorTest")
    test_logger.setLevel(logging.DEBUG)
    if not test_logger.handlers: # Avoid adding multiple handlers if run again
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s'))
        test_logger.addHandler(handler)

    print("\n--- Testing Basic Icon Detection ---")
    icon_detector_basic = IconDetector(test_logger, temporal_consistency_frames=1)

    frame = np.random.randint(0, 256, (300, 300, 3), dtype=np.uint8)
    test_logger.info(f"Created dummy frame with shape: {frame.shape}")
    template_coords = (50, 50, 100, 100)
    x, y, w, h = template_coords
    template = frame[y:y+h, x:x+w].copy()
    test_logger.info(f"Created dummy template with shape: {template.shape}")

    print("\nTest 1: Exact template match (should be found)")
    found, score, loc = icon_detector_basic.detect_icon(frame, template, 0.99)
    print(f"Result: found={found}, confidence={score:.4f}, location={loc}")
    assert found is True, "Test 1 Failed: Exact match not found"

    print("\nTest 2: Random template (should not be found)")
    random_template = np.random.randint(0, 256, (50, 50, 3), dtype=np.uint8)
    found, score, loc = icon_detector_basic.detect_icon(frame, random_template, 0.8)
    print(f"Result: found={found}, confidence={score:.4f}, location={loc}")
    assert found is False, "Test 2 Failed: Random template was found"

    print("\nTest 3: Template larger than frame (should fail gracefully)")
    large_template = np.random.randint(0, 256, (400, 400, 3), dtype=np.uint8)
    found, score, loc = icon_detector_basic.detect_icon(frame, large_template, 0.8)
    print(f"Result: found={found}, confidence={score:.4f}, location={loc}")
    assert found is False and score == 0.0 and loc is None, "Test 3 Failed: Template larger than frame did not fail gracefully"

    print("\n--- Testing Temporal Consistency ---")
    consistency_frames = 3
    icon_detector_temporal = IconDetector(test_logger, temporal_consistency_frames=consistency_frames)

    # Initial state: confirmed_detection_state = False
    # History deque maxlen is consistency_frames (3)
    test_sequence_temporal = [
        # (current_frame_found, expected_confirmed_state_after_update)
        (True, False),  # History: [T], Buffer not full (len 1/3), Confirmed: False
        (True, False),  # History: [T, T], Buffer not full (len 2/3), Confirmed: False
        (True, True),   # History: [T, T, T], Buffer full, All True, Confirmed: True (State Change)
        (False, True),  # History: [T, T, F], Buffer full, Mixed, Confirmed: True (No Change)
        (False, True),  # History: [T, F, F], Buffer full, Mixed, Confirmed: True (No Change)
        (False, False), # History: [F, F, F], Buffer full, All False, Confirmed: False (State Change)
        (False, False), # History: [F, F, F], Buffer full, All False, Confirmed: False (No Change)
        (True, False),  # History: [F, F, T], Buffer full, Mixed, Confirmed: False (No Change)
        (True, False),  # History: [F, T, T], Buffer full, Mixed, Confirmed: False (No Change)
        (True, True),   # History: [T, T, T], Buffer full, All True, Confirmed: True (State Change)
    ]

    icon_detector_temporal.detection_history.clear()
    icon_detector_temporal.confirmed_detection_state = False # Explicitly set initial state
    test_logger.info(f"Starting temporal consistency test. `temporal_consistency_frames` = {consistency_frames}. Initial `confirmed_detection_state` = False.")

    all_tests_passed = True
    for i, (current_found, expected_confirmed) in enumerate(test_sequence_temporal):
        print(f"\nEvent {i+1}: Input Raw Found = {current_found}, Current Confirmed State = {icon_detector_temporal.confirmed_detection_state}, History = {list(icon_detector_temporal.detection_history)}")
        actual_confirmed = icon_detector_temporal.update_consistent_detection_state(current_found)
        print(f" -> Output Confirmed State = {actual_confirmed} (Expected: {expected_confirmed})")
        if actual_confirmed != expected_confirmed:
            all_tests_passed = False
            print(f"   ❌ FAILED: Expected {expected_confirmed}, got {actual_confirmed}")
        else:
            print(f"   ✅ PASSED")
        time.sleep(0.01)

    print("\nTemporal Consistency Test Summary:")
    if all_tests_passed:
        print("✅ All temporal consistency tests passed.")
    else:
        print("❌ Some temporal consistency tests failed.")

    print("\n--- IconDetector Test Complete ---")

```
Provided content for `src/daoc_sprint_manager/core/icon_detector.py`.

Next, the `InputManager`.

```python name=src/daoc_sprint_manager/core/input_manager.py
"""
Manages keyboard input simulation using pydirectinput.

Provides methods to safely press, release, and send keypresses, primarily
for interacting with game clients or other applications. Includes validation
for supported key codes.
"""

import logging
import time
from typing import Set

try:
    import pydirectinput
    # Populate VALID_KEYS once at import time
    VALID_KEYS: Set[str] = set(pydirectinput.KEY_NAMES)
    PYDIRECTINPUT_AVAILABLE = True
except ImportError:
    VALID_KEYS: Set[str] = set(['a', 'b', 'c', 'space', 'enter', 'f1', 'f6', 'r', 'z', 'up', 'down', 'left', 'right']) # Example keys
    PYDIRECTINPUT_AVAILABLE = False


class InputManager:
    """
    Handles sending keyboard inputs using pydirectinput.

    Encapsulates key press and release actions, including validation and delays.

    CRITICAL USER RESPONSIBILITY: Automated input may violate game End User
    License Agreements (EULA). Use of this module is at the user's own risk.
    Ensure compliance with all game rules to avoid account penalties.
    """

    def __init__(self, logger: logging.Logger):
        """
        Initializes the InputManager.

        Args:
            logger: Logger instance for recording operations and errors.
        """
        self.logger = logger
        if not PYDIRECTINPUT_AVAILABLE:
            self.logger.critical(
                "pydirectinput library is not installed. Input functionality will not work. "
                "Install it using: pip install pydirectinput"
            )
        else:
            # Configure pydirectinput if needed (e.g., pause behavior)
            # pydirectinput.PAUSE = 0.01 # Default is 0.1, can be lowered
            pass
        self.logger.debug("InputManager initialized.")

    def _is_valid_key(self, key_code: str) -> bool:
        """
        Checks if the given key code is valid according to pydirectinput.

        Args:
            key_code: The key code string (e.g., 'a', 'f6', 'space').

        Returns:
            True if the key code is valid, False otherwise.
        """
        is_valid = key_code.lower() in VALID_KEYS
        if not is_valid:
            self.logger.warning(f"Invalid key code '{key_code}' specified. Supported keys: {sorted(list(VALID_KEYS[:10]))}... etc.")
        return is_valid

    def press_key(self, key_code: str) -> None:
        """
        Simulates pressing and holding down a key (keyDown).

        Args:
            key_code: The key code to press (must be a valid pydirectinput key).

        Raises:
            RuntimeError: If pydirectinput is not available.
        """
        if not PYDIRECTINPUT_AVAILABLE:
            self.logger.error("Cannot press key: pydirectinput is not available.")
            raise RuntimeError("pydirectinput is not installed")

        if not self._is_valid_key(key_code):
            return

        try:
            self.logger.debug(f"Pressing key (keyDown): '{key_code}'")
            pydirectinput.keyDown(key_code)
        except Exception as e: # Catching general Exception as pydirectinput might raise various things
            self.logger.error(f"pydirectinput error pressing key (keyDown) '{key_code}': {e}", exc_info=True)
            # Decide if to re-raise or handle gracefully
            # For now, log and continue is safer for an automation tool.
            # raise

    def release_key(self, key_code: str) -> None:
        """
        Simulates releasing a key (keyUp).

        Args:
            key_code: The key code to release (must be a valid pydirectinput key).

        Raises:
            RuntimeError: If pydirectinput is not available.
        """
        if not PYDIRECTINPUT_AVAILABLE:
            self.logger.error("Cannot release key: pydirectinput is not available.")
            raise RuntimeError("pydirectinput is not installed")

        if not self._is_valid_key(key_code):
            return

        try:
            self.logger.debug(f"Releasing key (keyUp): '{key_code}'")
            pydirectinput.keyUp(key_code)
        except Exception as e:
            self.logger.error(f"pydirectinput error releasing key (keyUp) '{key_code}': {e}", exc_info=True)
            # raise

    def send_keypress(self, key_code: str, press_duration_ms: int = 50) -> None:
        """
        Simulates a full keypress (keyDown, wait, keyUp).

        Args:
            key_code: The key code to send (must be a valid pydirectinput key).
            press_duration_ms: The duration to hold the key down in milliseconds. Minimum 10ms.

        Raises:
            RuntimeError: If pydirectinput is not available.
        """
        if not PYDIRECTINPUT_AVAILABLE:
            self.logger.error("Cannot send keypress: pydirectinput is not available.")
            raise RuntimeError("pydirectinput is not installed")

        if not self._is_valid_key(key_code):
            self.logger.warning(f"Skipping send_keypress for invalid key: {key_code}")
            return

        try:
            self.logger.info(f"Sending keypress: '{key_code}' (duration: {press_duration_ms}ms)")
            pydirectinput.keyDown(key_code)
            time.sleep(max(0.01, press_duration_ms / 1000.0)) # Ensure a minimum sleep of 10ms
            pydirectinput.keyUp(key_code)
            self.logger.debug(f"Keypress '{key_code}' completed.")
        except Exception as e:
            self.logger.error(f"pydirectinput error sending keypress '{key_code}': {e}", exc_info=True)
            # raise


if __name__ == "__main__":
    import sys
    # Set up a basic logger for testing
    test_logger = logging.getLogger("InputManagerTest")
    test_logger.setLevel(logging.DEBUG)
    if not test_logger.handlers:
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s'))
        test_logger.addHandler(handler)

    input_manager = InputManager(test_logger)

    if not PYDIRECTINPUT_AVAILABLE:
        test_logger.critical("pydirectinput is not installed. InputManager tests cannot be fully executed.")
        print("Please install pydirectinput: pip install pydirectinput")
    else:
        print("\n--- Testing InputManager ---")
        print("CRITICAL: This test will send a keypress.")
        print("Please focus a text editor (like Notepad) within the next 5 seconds.")
        print("A 'z' keypress will be sent.")
        for i in range(5, 0, -1):
            print(f"{i}...", end=" ", flush=True)
            time.sleep(1)
        print("Sending!")

        try:
            print("\nTest 1: Sending 'z' keypress (duration 100ms)...")
            input_manager.send_keypress('z', press_duration_ms=100)
            print("-> Check your text editor for the 'z' character.")
        except RuntimeError as e:
            print(f"   ERROR during keypress: {e} (This is expected if pydirectinput is missing)")
        except Exception as e:
            print(f"   UNEXPECTED ERROR during keypress: {e}")

        time.sleep(2)

        try:
            print("\nTest 2: Sending an invalid key ('invalidkeyname')...")
            input_manager.send_keypress('invalidkeyname', press_duration_ms=50)
            print("-> This should log a warning and not send anything if the key is truly invalid.")
        except RuntimeError as e:
            print(f"   ERROR during invalid keypress: {e} (This is expected if pydirectinput is missing)")
        except Exception as e:
            print(f"   UNEXPECTED ERROR during invalid keypress: {e}")


        print("\nTest 3: Testing press/release separately ('b' key)...")
        print("Focus text editor again in 3 seconds...")
        time.sleep(3)
        print("   Pressing 'b'...")
        try:
            input_manager.press_key('b')
            time.sleep(0.5) # Hold for 0.5 sec
            print("   Releasing 'b'...")
            input_manager.release_key('b')
            print("-> If focus was on text editor, 'b' might appear.")
        except RuntimeError as e:
            print(f"   ERROR during press/release: {e} (This is expected if pydirectinput is missing)")
        except Exception as e:
            print(f"   UNEXPECTED ERROR during press/release test: {e}")


        print("\n--- InputManager Test Complete ---")
        print("Please verify the output in your text editor.")

```
Provided content for `src/daoc_sprint_manager/core/input_manager.py`.

Next, `PerformanceMonitor`.

```python name=src/daoc_sprint_manager/utils/performance_monitor.py
"""
Utility for monitoring script performance metrics.

Provides methods to time code sections and retrieve system resource usage
(CPU, Memory) for the current process.
"""

import logging
import os
import time
from typing import Dict, Optional, Tuple

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

class PerformanceMonitor:
    """
    Monitors script performance including execution time and resource usage.
    """

    def __init__(self, logger: logging.Logger):
        """
        Initializes the PerformanceMonitor.

        Args:
            logger: Logger instance for recording operations and errors.
        """
        self.logger = logger
        self.timers: Dict[str, float] = {}
        self.last_lap_times: Dict[str, float] = {}
        self.process: Optional[psutil.Process] = None

        if not PSUTIL_AVAILABLE:
            self.logger.warning(
                "psutil library is not installed. Resource monitoring will be disabled. "
                "Install it using: pip install psutil"
            )
        else:
            try:
                self.process = psutil.Process(os.getpid())
                # Prime the cpu_percent call as the first call returns 0 or requires interval for comparison
                self.process.cpu_percent(interval=None)
                self.logger.debug("PerformanceMonitor initialized with psutil.")
            except psutil.Error as e: # Catch specific psutil errors
                 self.logger.error(f"Could not get current process information using psutil: {e}. Resource monitoring disabled.")
                 self.process = None # Ensure process is None if init fails
            except Exception as e: # Catch any other unexpected error
                 self.logger.exception(f"Unexpected error initializing psutil.Process: {e}. Resource monitoring disabled.")
                 self.process = None


    def start_timer(self, name: str) -> None:
        """
        Starts a performance timer with the given name.

        Args:
            name: An identifier for the timer.
        """
        self.timers[name] = time.perf_counter()
        self.logger.debug(f"Timer '{name}' started.")

    def stop_timer(self, name: str) -> Optional[float]:
        """
        Stops the performance timer with the given name and returns the duration.

        Args:
            name: The identifier of the timer to stop.

        Returns:
            The elapsed time in seconds since the timer was started,
            or None if the timer name was not found.
        """
        if name not in self.timers:
            self.logger.error(f"Timer '{name}' was stopped but never started.")
            return None

        start_time = self.timers.pop(name) # Remove timer after stopping
        end_time = time.perf_counter()
        duration = end_time - start_time
        self.last_lap_times[name] = duration # Store the duration
        self.logger.debug(f"Timer '{name}' stopped. Duration: {duration:.6f} seconds.")
        return duration

    def get_fps(self, cycle_time_s: float) -> float:
        """
        Calculates Frames Per Second (FPS) based on a cycle time.

        Args:
            cycle_time_s: The duration of one cycle in seconds.

        Returns:
            The calculated FPS, or 0.0 if cycle time is non-positive or too small.
        """
        if cycle_time_s > 0.00001: # Avoid division by zero or very small numbers leading to huge FPS
            return 1.0 / cycle_time_s
        self.logger.debug(f"Cycle time {cycle_time_s:.6f}s too small or non-positive, returning 0.0 FPS.")
        return 0.0

    def get_script_resource_usage(self) -> Tuple[Optional[float], Optional[float]]:
        """
        Gets the current CPU and Memory usage for the script's process.

        Returns:
            A tuple containing:
            - float or None: CPU usage percentage (since last call or process start).
            - float or None: Memory usage in MB (Resident Set Size).
            Returns (None, None) if psutil is unavailable or fails.
        """
        if not self.process: # Check if psutil.Process object was successfully initialized
             self.logger.debug("Cannot get resource usage: psutil process not available or not initialized.")
             return None, None

        try:
            # cpu_percent(interval=None) returns the usage since the last call,
            # or since process creation if it's the first call without interval.
            cpu_percent: Optional[float] = self.process.cpu_percent(interval=None)

            # memory_info().rss gives the Resident Set Size in bytes
            memory_bytes = self.process.memory_info().rss
            memory_mb: Optional[float] = memory_bytes / (1024 * 1024) # Convert bytes to MB

            self.logger.debug(f"Resource usage: CPU={cpu_percent:.1f}%, Memory={memory_mb:.2f}MB" if cpu_percent is not None and memory_mb is not None else "Resource usage: Data unavailable")
            return cpu_percent, memory_mb

        except psutil.Error as e: # Catch specific psutil errors
             self.logger.error(f"psutil error getting resource usage: {e}")
             return None, None
        except Exception as e: # Catch any other unexpected error
             self.logger.exception(f"Unexpected error getting resource usage: {e}")
             return None, None


if __name__ == "__main__":
    import sys
    # Set up a basic logger for testing
    test_logger = logging.getLogger("PerfMonTest")
    test_logger.setLevel(logging.DEBUG)
    if not test_logger.handlers:
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s'))
        test_logger.addHandler(handler)

    monitor = PerformanceMonitor(test_logger)

    print("\n--- Testing PerformanceMonitor ---")

    # Test Timer functionality
    print("\nTest 1: Timing a short task...")
    monitor.start_timer("short_sleep")
    time.sleep(0.1534) # Sleep for ~153ms
    duration = monitor.stop_timer("short_sleep")
    if duration is not None:
        print(f" -> Measured duration: {duration:.4f} seconds (expected ~0.1534s)")
        assert 0.15 < duration < 0.16, "Timer duration out of expected range"
        print(f" -> Stored lap time: {monitor.last_lap_times.get('short_sleep'):.4f} seconds")
    else:
        print(" -> Failed to get duration for 'short_sleep'.")
        assert False, "stop_timer returned None unexpectedly"


    print("\nTest 2: Trying to stop a non-existent timer...")
    duration_fail = monitor.stop_timer("non_existent_timer")
    print(f" -> Result for 'non_existent_timer': {duration_fail} (expected None)")
    assert duration_fail is None, "Stopping non-existent timer should return None"

    # Test FPS calculation
    print("\nTest 3: Calculating FPS...")
    cycle_time_1 = 0.1 # Expected 10 FPS
    cycle_time_2 = 1.0 / 60.0 # Expected 60 FPS
    cycle_time_3 = 0.0 # Expected 0 FPS
    fps1 = monitor.get_fps(cycle_time_1)
    fps2 = monitor.get_fps(cycle_time_2)
    fps3 = monitor.get_fps(cycle_time_3)
    print(f" -> FPS for cycle time {cycle_time_1:.4f}s: {fps1:.1f} FPS (Expected: 10.0)")
    print(f" -> FPS for cycle time {cycle_time_2:.4f}s: {fps2:.1f} FPS (Expected: 60.0)")
    print(f" -> FPS for cycle time {cycle_time_3:.4f}s: {fps3:.1f} FPS (Expected: 0.0)")
    assert abs(fps1 - 10.0) < 0.1, f"FPS1 expected ~10.0, got {fps1}"
    assert abs(fps2 - 60.0) < 0.1, f"FPS2 expected ~60.0, got {fps2}"
    assert abs(fps3 - 0.0) < 0.0001, f"FPS3 expected 0.0, got {fps3}"


    # Test Resource Usage (if psutil is available)
    print("\nTest 4: Getting resource usage...")
    if monitor.process: # Check if psutil.Process object was initialized
        # Initial call, cpu_percent might be 0.0 or low
        cpu, mem = monitor.get_script_resource_usage()
        print(f" -> Initial Usage: CPU = {f'{cpu:.1f}%' if cpu is not None else 'N/A'}, Memory = {f'{mem:.2f}MB' if mem is not None else 'N/A'}")

        # Simulate some CPU work
        print(" -> Simulating CPU work (list comprehension)...")
        start_work_time = time.perf_counter()
        # This list comprehension will use some CPU
        _ = [x*x for x in range(2 * 10**6)] # Increased range for more noticeable CPU usage
        work_duration = time.perf_counter() - start_work_time
        print(f" -> CPU work took {work_duration:.3f}s")
        
        time.sleep(0.1) # Give psutil a moment to update after work

        cpu_after_work, mem_after_work = monitor.get_script_resource_usage()
        print(f" -> Usage after work: CPU = {f'{cpu_after_work:.1f}%' if cpu_after_work is not None else 'N/A'}, Memory = {f'{mem_after_work:.2f}MB' if mem_after_work is not None else 'N/A'}")
        if cpu_after_work is not None:
             assert cpu_after_work >= 0.0, "CPU usage should be non-negative"
        if mem_after_work is not None:
             assert mem_after_work > 0.0, "Memory usage should be positive"
    else:
        print(" -> Skipping resource usage test because psutil is not available or failed to initialize.")

    print("\n--- PerformanceMonitor Test Complete ---")
```
Provided content for `src/daoc_sprint_manager/utils/performance_monitor.py`.

Next, the updated `main.py` integrating the Performance Monitor.

```python name=src/daoc_sprint_manager/main.py
"""
Main application entry point for the DAOC Sprint Manager.

Initializes components, manages the main detection loop, handles
application lifecycle events, and incorporates performance monitoring.
"""

import logging
import pathlib
import sys
import time
import os # Added for os.chdir

try:
    import pygetwindow
    PYGETWINDOW_AVAILABLE = True
except ImportError:
    PYGETWINDOW_AVAILABLE = False
    print("WARNING: pygetwindow library not found. Window focus checking will be disabled. Install with: pip install pygetwindow")


# Import project modules
try:
    # For direct execution of this file
    from utils.logger import setup_logger
    from config_manager import ConfigManager
    from data_models import AppSettings
    from core.window_manager import WindowManager
    from core.icon_detector import IconDetector
    from core.input_manager import InputManager # Added
    from utils.performance_monitor import PerformanceMonitor # Added
except ImportError:
    # When imported as a module within the package
    from .utils.logger import setup_logger
    from .config_manager import ConfigManager
    from .data_models import AppSettings
    from .core.window_manager import WindowManager
    from .core.icon_detector import IconDetector
    from .core.input_manager import InputManager # Added
    from .utils.performance_monitor import PerformanceMonitor # Added


# Define ROOT_DIR relative to this file's location
ROOT_DIR = pathlib.Path(__file__).resolve().parent.parent.parent
LOGS_DIR = ROOT_DIR / "logs"


def run_application():
    """Initializes and runs the main application logic."""
    # --- Preliminary Setup ---
    prelim_log_file = LOGS_DIR / "startup_app.log"
    try:
        LOGS_DIR.mkdir(parents=True, exist_ok=True)
        prelim_logger = setup_logger("startup", prelim_log_file, logging.DEBUG)
        prelim_logger.info(f"Preliminary logging started. Project Root: {ROOT_DIR}")
    except Exception as e:
        print(f"FATAL: Could not set up preliminary logger at {prelim_log_file}: {e}", file=sys.stderr)
        sys.exit(1)

    # --- Configuration Loading ---
    main_logger = prelim_logger
    try:
        settings_file = ROOT_DIR / "config" / "settings.json"
        template_file = ROOT_DIR / "config" / "settings.json.template"
        main_logger.info(f"Settings path: {settings_file}")
        main_logger.info(f"Template path: {template_file}")

        config_manager = ConfigManager(settings_file, template_file, main_logger)
        app_settings: AppSettings = config_manager.load_settings()

        # --- Main Logger Setup ---
        actual_log_file_path = LOGS_DIR / app_settings.log_file_name
        log_level_from_config = getattr(logging, app_settings.log_level.upper(), logging.INFO)
        main_logger = setup_logger("DAOCSprintManager", actual_log_file_path, log_level_from_config)
        main_logger.info("Main application logger initialized.")
        main_logger.info(f"Logging to file: {actual_log_file_path}")
        main_logger.info(f"Log level set to: {app_settings.log_level}")

    except Exception as e:
        main_logger.critical(f"Failed during configuration or main logger setup: {e}", exc_info=True)
        sys.exit(1)

    # --- Check Dependencies ---
    if not PYGETWINDOW_AVAILABLE:
        main_logger.critical("pygetwindow library is not installed. Focus checking functionality will be severely limited or non-functional.")
        # Depending on strictness, could sys.exit(1) here. For now, allow degraded mode.

    # --- Application Start ---
    main_logger.info("Application initializing...")
    main_logger.debug(f"Loaded settings: {app_settings}")
    main_logger.debug(f"Project Root Directory: {ROOT_DIR}")

    # --- Initialize Core Components ---
    try:
        perf_monitor = PerformanceMonitor(main_logger) # Instantiate Perf Monitor
        main_logger.info("Performance monitor initialized.")

        window_manager = WindowManager(main_logger)
        main_logger.info("Window manager initialized.")

        icon_detector = IconDetector(main_logger, app_settings.temporal_consistency_frames)
        main_logger.info("Icon detector initialized.")

        input_manager = InputManager(main_logger)
        main_logger.info("Input manager initialized.")

        sprint_on_template_path = ROOT_DIR / app_settings.sprint_on_icon_path
        loaded_template = icon_detector.load_template(sprint_on_template_path)

        if loaded_template is None:
            main_logger.critical(f"Failed to load sprint 'ON' icon template from {sprint_on_template_path}. Exiting.")
            sys.exit(1)
        main_logger.info("Sprint 'ON' icon template loaded successfully.")

    except Exception as e:
        main_logger.critical(f"Failed during component initialization: {e}", exc_info=True)
        sys.exit(1)

    # --- Main Detection Loop ---
    main_logger.info("Starting main detection loop...")
    sprint_key_physical_state: bool = False
    try:
        while True:
            perf_monitor.start_timer("full_cycle") # Start full cycle timer

            find_time = capture_time = detection_time = None # Reset timers for this iteration

            # --- Find Window ---
            perf_monitor.start_timer("window_find")
            game_window = window_manager.find_window(app_settings.game_window_title)
            find_time = perf_monitor.stop_timer("window_find")

            if game_window is None:
                main_logger.warning(f"Game window '{app_settings.game_window_title}' not found. Retrying in {app_settings.game_not_found_retry_delay_s}s...")
                if sprint_key_physical_state:
                    try:
                        input_manager.release_key(app_settings.sprint_key)
                        sprint_key_physical_state = False
                        main_logger.info(f"Sprint key '{app_settings.sprint_key}' RELEASED. Reason: Game window lost.")
                    except Exception as release_err:
                         main_logger.error(f"Error releasing key after game window lost: {release_err}")
                # Stop full cycle timer here before continuing to get accurate sleep
                full_cycle_time = perf_monitor.stop_timer("full_cycle") # Get current cycle time before sleep
                time.sleep(app_settings.game_not_found_retry_delay_s)
                continue

            # --- Capture ROI ---
            perf_monitor.start_timer("roi_capture")
            frame = window_manager.capture_roi_from_window(
                game_window,
                app_settings.roi_x,
                app_settings.roi_y,
                app_settings.roi_width,
                app_settings.roi_height
            )
            capture_time = perf_monitor.stop_timer("roi_capture")

            if frame is None:
                main_logger.warning(f"Failed to capture ROI from game window. Retrying in {app_settings.capture_error_retry_delay_s}s...")
                if sprint_key_physical_state:
                    main_logger.warning("ROI capture failed while sprint key is potentially held down.")
                full_cycle_time = perf_monitor.stop_timer("full_cycle")
                time.sleep(app_settings.capture_error_retry_delay_s)
                continue

            # --- Detect Icon ---
            perf_monitor.start_timer("icon_detection")
            raw_found, score, loc_rect = icon_detector.detect_icon(
                frame,
                loaded_template,
                app_settings.template_match_threshold
            )
            detection_time = perf_monitor.stop_timer("icon_detection")

            # --- Temporal Consistency ---
            confirmed_icon_is_active = icon_detector.update_consistent_detection_state(raw_found)
            main_logger.debug(f"Detection Frame: RawFound={raw_found}, Score={score:.2f}, ConfirmedState={confirmed_icon_is_active}, Location={loc_rect}")


            # --- Input Logic ---
            is_game_focused = False
            active_win_title = "N/A (pygetwindow not available or error)"
            if PYGETWINDOW_AVAILABLE:
                try:
                    active_win = pygetwindow.getActiveWindow()
                    if active_win and app_settings.game_window_title.lower() in active_win.title.lower():
                        is_game_focused = True
                    active_win_title = active_win.title if active_win else "None"
                except Exception as focus_err: # Catch broader exceptions from pygetwindow
                     main_logger.warning(f"Could not get active window title: {focus_err}")
            else: # If pygetwindow is not available, we cannot determine focus, so we might act cautiously
                main_logger.debug("pygetwindow not available, cannot check game window focus. Proceeding with input logic based on icon state only.")
                # Fallback behavior: If pygetwindow is missing, assume game is focused if window was found.
                # This is a simplification. A real app might handle this more gracefully
                # or make focus checking a hard requirement.
                is_game_focused = True if game_window else False


            if confirmed_icon_is_active and not sprint_key_physical_state and is_game_focused:
                try:
                    input_manager.press_key(app_settings.sprint_key)
                    sprint_key_physical_state = True
                    main_logger.info(f"Sprint key '{app_settings.sprint_key}' PRESSED. Reason: Icon confirmed active, key was released, game focused.")
                except Exception as press_err:
                    main_logger.error(f"Error pressing sprint key '{app_settings.sprint_key}': {press_err}")
            elif not confirmed_icon_is_active and sprint_key_physical_state:
                try:
                    input_manager.release_key(app_settings.sprint_key)
                    sprint_key_physical_state = False
                    main_logger.info(f"Sprint key '{app_settings.sprint_key}' RELEASED. Reason: Icon confirmed inactive, key was pressed.")
                except Exception as release_err:
                    main_logger.error(f"Error releasing sprint key '{app_settings.sprint_key}': {release_err}")
            elif confirmed_icon_is_active and sprint_key_physical_state and not is_game_focused:
                 try:
                    input_manager.release_key(app_settings.sprint_key)
                    sprint_key_physical_state = False
                    main_logger.info(f"Sprint key '{app_settings.sprint_key}' RELEASED. Reason: Game window ('{app_settings.game_window_title}') lost focus. Active window: '{active_win_title}'.")
                 except Exception as release_err:
                    main_logger.error(f"Error releasing key on focus loss '{app_settings.sprint_key}': {release_err}")
            elif confirmed_icon_is_active and not sprint_key_physical_state and not is_game_focused:
                 main_logger.debug(f"Sprint icon active, but game window ('{app_settings.game_window_title}') not focused. Active window: '{active_win_title}'. Sprint key press skipped.")


            # --- Performance Logging & Loop Delay ---
            full_cycle_time = perf_monitor.stop_timer("full_cycle")

            if app_settings.show_performance_metrics and full_cycle_time is not None:
                fps = perf_monitor.get_fps(full_cycle_time)
                cpu_usage, mem_usage_mb = perf_monitor.get_script_resource_usage()
                cpu_str = f"{cpu_usage:.1f}" if cpu_usage is not None else "N/A"
                mem_str = f"{mem_usage_mb:.1f}" if mem_usage_mb is not None else "N/A"
                find_ms_str = f"{find_time*1000:.1f}" if find_time is not None else 'N/A'
                capture_ms_str = f"{capture_time*1000:.1f}" if capture_time is not None else 'N/A'
                detect_ms_str = f"{detection_time*1000:.1f}" if detection_time is not None else 'N/A'

                main_logger.debug(
                    f"Perf: Cycle={full_cycle_time*1000:.2f}ms (FPS:{fps:.1f}), "
                    f"CPU={cpu_str}%, MEM={mem_str}MB. "
                    f"Timings(ms): Find={find_ms_str}, Capture={capture_ms_str}, Detect={detect_ms_str}"
                )

            # Calculate sleep duration based on full cycle time
            target_delay = 1.0 / app_settings.capture_fps if app_settings.capture_fps > 0 else 0.1
            current_elapsed_time = full_cycle_time if full_cycle_time is not None else 0
            sleep_duration = max(0, target_delay - current_elapsed_time)

            if full_cycle_time is not None : # Only log if full_cycle_time is valid
                main_logger.debug(f"Loop finished in {current_elapsed_time*1000:.1f}ms. Sleeping for {sleep_duration:.4f}s.")
            else:
                main_logger.debug(f"Full cycle time is None. Defaulting sleep based on target_delay. Sleeping for {sleep_duration:.4f}s.")

            time.sleep(sleep_duration)

    except KeyboardInterrupt:
        main_logger.info("Application terminated by user (KeyboardInterrupt).")
    except Exception as e: # Catch any other unhandled exceptions in the main loop
        main_logger.critical(f"Unhandled exception in main loop: {e}", exc_info=True)
        if sprint_key_physical_state: # Attempt to release key on error
            try:
                main_logger.warning("Releasing sprint key due to unexpected application exit.")
                input_manager.release_key(app_settings.sprint_key)
            except Exception as final_release_err:
                 main_logger.error(f"Error during final key release on unhandled exception: {final_release_err}")
        return 1 # Indicate error exit
    finally:
        if sprint_key_physical_state:
            try:
                main_logger.info("Releasing sprint key on application shutdown (finally block).")
                input_manager.release_key(app_settings.sprint_key)
            except Exception as final_release_err:
                 main_logger.error(f"Error during final key release on shutdown (finally block): {final_release_err}")
        main_logger.info("Application shutdown sequence complete.")
        return 0 # Indicate normal or planned exit


if __name__ == "__main__":
    # --- PyInstaller / Path Setup ---
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
         # Running as a bundled app (e.g., PyInstaller)
         # sys._MEIPASS is the temp dir PyInstaller creates
         ROOT_DIR = pathlib.Path(sys._MEIPASS)
         print(f"Running as bundled app, _MEIPASS ROOT_DIR set to: {ROOT_DIR}")
    else:
         # Running as a script, ROOT_DIR defined above is correct
         print(f"Running as script, ROOT_DIR: {ROOT_DIR}")
         # If run directly, ensure CWD is project root for relative paths in config
         try:
             os.chdir(ROOT_DIR)
             print(f"Changed CWD to: {os.getcwd()}")
         except Exception as e:
             print(f"Could not change CWD to ROOT_DIR {ROOT_DIR}: {e}")


    # Setup basic logging immediately in case run_application fails early
    initial_logger = logging.getLogger("main_entry")
    initial_logger.setLevel(logging.INFO)
    if not initial_logger.handlers: # Avoid adding multiple handlers
        initial_handler = logging.StreamHandler(sys.stdout)
        initial_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s')
        initial_handler.setFormatter(initial_formatter)
        initial_logger.addHandler(initial_handler)

    exit_code = 1 # Default to error
    try:
        exit_code = run_application()
        if exit_code == 0:
            initial_logger.info("Application finished normally.")
        else:
            initial_logger.error(f"Application exited with error code: {exit_code}")

    except KeyboardInterrupt:
        initial_logger.info("Application terminated by user from __main__ (KeyboardInterrupt).")
        exit_code = 0 # User termination is not an error
    except Exception as e: # Catch-all for __main__
         initial_logger.critical(f"Critical unhandled exception in __main__: {e}", exc_info=True)
         exit_code = 1
    finally:
        initial_logger.info("Main execution block finished.")
        logging.shutdown() # Ensure all handlers are flushed
        print("Main shutdown sequence complete.")
        sys.exit(exit_code)
```
Provided content for `src/daoc_sprint_manager/main.py`.

Next, the `SprintManagerApp` class in `tray_app.py`.

```python name=src/daoc_sprint_manager/ui/tray_app.py
"""
System tray application class for DAOC Sprint Manager.

Handles the system tray icon, menu, threading for the detection loop,
and overall application lifecycle management.
"""

import logging
import os
import pathlib
import subprocess
import sys
import threading
import time
from typing import Optional

try:
    import pystray
    from PIL import Image, UnidentifiedImageError
    PYSTRAY_AVAILABLE = True
except ImportError:
    PYSTRAY_AVAILABLE = False
    # This module is critical for the tray app. Logging will be done in __init__.

try:
    import pygetwindow
    PYGETWINDOW_AVAILABLE = True
except ImportError:
    PYGETWINDOW_AVAILABLE = False
    # Warning will be logged if this is missing, as focus checking will be degraded.


# Import project components
# This structure assumes tray_app.py is in src/daoc_sprint_manager/ui/
# Adjust relative imports if the file structure is different.
try:
    from ..data_models import AppSettings
    from ..core.window_manager import WindowManager
    from ..core.icon_detector import IconDetector
    from ..core.input_manager import InputManager
    from ..utils.performance_monitor import PerformanceMonitor
except ImportError:
    # This block is for cases where the script might be run directly for testing
    # or if the package structure isn't correctly recognized by the Python path.
    # It tries to adjust sys.path to allow direct imports from sibling directories.
    # This is a common pattern but might need adjustment based on specific project layout.
    current_dir = pathlib.Path(__file__).parent.resolve()
    project_src_dir = current_dir.parent # Moves up one level from 'ui' to 'daoc_sprint_manager'
    if str(project_src_dir) not in sys.path:
         sys.path.insert(0, str(project_src_dir))
    
    from data_models import AppSettings
    from core.window_manager import WindowManager
    from core.icon_detector import IconDetector
    from core.input_manager import InputManager
    from utils.performance_monitor import PerformanceMonitor

class SprintManagerApp:
    """
    Manages the system tray application, detection loop thread, and state.
    """

    def __init__(self, app_settings: AppSettings, logger: logging.Logger, root_dir: pathlib.Path):
        """
        Initializes the SprintManagerApp.

        Args:
            app_settings: Loaded application settings.
            logger: Logger instance.
            root_dir: The root directory of the project.
        """
        self.app_settings = app_settings
        self.logger = logger
        self.root_dir = root_dir

        if not PYSTRAY_AVAILABLE:
            self.logger.critical("pystray or Pillow library not found. System tray UI cannot run. Install using: pip install pystray Pillow")
            sys.exit("FATAL: Missing required libraries (pystray, Pillow) for tray application.")
        
        if not PYGETWINDOW_AVAILABLE:
            self.logger.warning("pygetwindow library not found. Game window focus checking will be disabled. Install using: pip install pygetwindow")


        # --- Shared State ---
        self.stop_event = threading.Event()
        self.pause_event = threading.Event()
        self.status_message: str = "Initializing..."
        self.status_lock = threading.Lock()
        self.pystray_icon: Optional[pystray.Icon] = None
        self.sprint_key_physical_state: bool = False
        self.detection_thread: Optional[threading.Thread] = None

        # --- Initialize Core Components ---
        self.perf_monitor = PerformanceMonitor(self.logger)
        self.window_manager = WindowManager(self.logger)
        self.icon_detector = IconDetector(self.logger, self.app_settings.temporal_consistency_frames)
        self.input_manager = InputManager(self.logger)

        # --- Load Template ---
        sprint_on_template_path = self.root_dir / self.app_settings.sprint_on_icon_path
        self.sprint_on_template = self.icon_detector.load_template(sprint_on_template_path)
        if self.sprint_on_template is None:
             self.logger.critical(f"Failed to load sprint 'ON' template from {sprint_on_template_path}. Application cannot start.")
             sys.exit(f"FATAL: Sprint 'ON' template missing at {sprint_on_template_path}.")

        self.logger.info("SprintManagerApp initialized successfully.")

    def _update_status(self, message: str):
        """Thread-safely update the status message and tray icon tooltip."""
        with self.status_lock:
            self.status_message = message
            if self.pystray_icon:
                 self.pystray_icon.title = f"DAOC Sprint Manager: {self.status_message}"
                 # pystray typically updates its menu when its 'menu' property is accessed
                 # or via icon.update_menu() if supported by the backend.
                 # For dynamic text in menu items, the menu property getter is often used.
        self.logger.info(f"Status updated: {message}")


    def _on_clicked_pause_resume(self, icon: Optional[pystray.Icon], item: Optional[pystray.MenuItem]):
        """Callback for the Pause/Resume menu item."""
        if self.pause_event.is_set():
            self.pause_event.clear()
            self._update_status("Running")
            self.logger.info("Application Resumed.")
        else:
            self.pause_event.set()
            self._update_status("Paused")
            self.logger.info("Application Paused.")
        if self.pystray_icon: # Ensure menu is re-rendered if check state changes
             self.pystray_icon.update_menu()


    def _on_clicked_open_config(self, icon: Optional[pystray.Icon], item: Optional[pystray.MenuItem]):
        """Callback for the Open Config menu item."""
        config_path = self.root_dir / "config" / "settings.json"
        self.logger.info(f"Attempting to open config file: {config_path}")
        try:
            if not config_path.exists():
                 self.logger.error(f"Config file {config_path} does not exist. Cannot open.")
                 # Optionally, try to create it from template if it's missing entirely
                 template_path = self.root_dir / "config" / "settings.json.template"
                 if template_path.exists():
                     shutil.copy(template_path, config_path)
                     self.logger.info(f"Created {config_path} from template. Please edit and restart if needed.")
                 else:
                     self.logger.error(f"Template file {template_path} also missing. Cannot create config.")
                     return

            if sys.platform == "win32":
                os.startfile(str(config_path))
            elif sys.platform == "darwin":
                subprocess.call(['open', str(config_path)])
            else: # Linux and other Unix-like
                subprocess.call(['xdg-open', str(config_path)])
        except FileNotFoundError: # Should be handled by exists check, but good for robustness
            self.logger.error(f"Config file not found at {config_path} during open attempt.")
        except Exception as e:
            self.logger.exception(f"Error opening config file {config_path}: {e}")

    def _on_clicked_exit(self, icon: Optional[pystray.Icon], item: Optional[pystray.MenuItem]):
        """Callback for the Exit menu item."""
        self.logger.info("Exit requested from tray menu.")
        self._update_status("Exiting...")
        self.stop_event.set()
        if self.pystray_icon:
            self.pystray_icon.stop()

    @property
    def menu(self) -> pystray.Menu:
        """Dynamically generates the tray menu."""
        paused_state = self.pause_event.is_set()
        status_item_text = f"Status: {self.status_message}"

        return pystray.Menu(
            pystray.MenuItem(status_item_text, None, enabled=False),
            pystray.Menu.SEPARATOR,
            pystray.MenuItem(
                'Pause' if not paused_state else 'Resume',
                self._on_clicked_pause_resume,
                checked=lambda item: self.pause_event.is_set() # Check dynamically
            ),
            pystray.MenuItem('Open Config', self._on_clicked_open_config),
            pystray.MenuItem('Exit', self._on_clicked_exit)
        )

    def run_detection_logic(self):
        """The main detection loop that runs in a separate thread."""
        self.logger.info("Detection thread started.")
        last_perf_log_time = time.monotonic()

        while not self.stop_event.is_set():
            loop_start_time = time.monotonic()

            if self.pause_event.is_set():
                if self.sprint_key_physical_state:
                    try:
                        self.input_manager.release_key(self.app_settings.sprint_key)
                        self.sprint_key_physical_state = False
                        self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' RELEASED due to pause.")
                    except Exception as release_err:
                         self.logger.error(f"Error releasing key on pause: {release_err}")
                self.stop_event.wait(timeout=1.0) # Check stop_event periodically while paused
                continue

            self.perf_monitor.start_timer("full_cycle")
            find_time, capture_time, detection_time = None, None, None

            self.perf_monitor.start_timer("window_find")
            game_window = self.window_manager.find_window(self.app_settings.game_window_title)
            find_time = self.perf_monitor.stop_timer("window_find")

            if game_window is None:
                self._update_status("Game Not Found")
                if self.sprint_key_physical_state:
                     try:
                         self.input_manager.release_key(self.app_settings.sprint_key)
                         self.sprint_key_physical_state = False
                         self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' RELEASED (Game window lost).")
                     except Exception as release_err:
                         self.logger.error(f"Error releasing key (Game window lost): {release_err}")
                self.perf_monitor.stop_timer("full_cycle") # Stop timer before sleep
                self.stop_event.wait(timeout=self.app_settings.game_not_found_retry_delay_s)
                continue

            self.perf_monitor.start_timer("roi_capture")
            frame = self.window_manager.capture_roi_from_window(
                game_window, self.app_settings.roi_x, self.app_settings.roi_y,
                self.app_settings.roi_width, self.app_settings.roi_height
            )
            capture_time = self.perf_monitor.stop_timer("roi_capture")

            if frame is None:
                self._update_status("Capture Error")
                if self.sprint_key_physical_state:
                    self.logger.warning("ROI capture failed while sprint key is potentially held down.")
                self.perf_monitor.stop_timer("full_cycle")
                self.stop_event.wait(timeout=self.app_settings.capture_error_retry_delay_s)
                continue

            self.perf_monitor.start_timer("icon_detection")
            raw_found, score, _ = self.icon_detector.detect_icon(
                frame, self.sprint_on_template, self.app_settings.template_match_threshold
            )
            detection_time = self.perf_monitor.stop_timer("icon_detection")
            confirmed_icon_is_active = self.icon_detector.update_consistent_detection_state(raw_found)
            current_status_msg = "Icon Active" if confirmed_icon_is_active else "Icon Inactive"

            is_game_focused = False
            active_win_title = "N/A (pygetwindow error or not available)"
            if PYGETWINDOW_AVAILABLE:
                try:
                    active_win = pygetwindow.getActiveWindow()
                    if active_win and self.app_settings.game_window_title.lower() in active_win.title.lower():
                        is_game_focused = True
                    active_win_title = active_win.title if active_win else "None"
                except Exception as focus_err:
                    self.logger.warning(f"Could not get active window title: {focus_err}")
            else: # Fallback if pygetwindow is missing
                 is_game_focused = True # Assume focused if library missing, to allow core functionality

            if confirmed_icon_is_active and not self.sprint_key_physical_state and is_game_focused:
                try:
                    self.input_manager.press_key(self.app_settings.sprint_key)
                    self.sprint_key_physical_state = True
                    self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' PRESSED.")
                except Exception as press_err:
                    self.logger.error(f"Error pressing sprint key: {press_err}")
            elif not confirmed_icon_is_active and self.sprint_key_physical_state:
                try:
                    self.input_manager.release_key(self.app_settings.sprint_key)
                    self.sprint_key_physical_state = False
                    self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' RELEASED (Icon inactive).")
                except Exception as release_err:
                    self.logger.error(f"Error releasing sprint key: {release_err}")
            elif confirmed_icon_is_active and self.sprint_key_physical_state and not is_game_focused:
                 try:
                    self.input_manager.release_key(self.app_settings.sprint_key)
                    self.sprint_key_physical_state = False
                    self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' RELEASED (Game lost focus: '{active_win_title}').")
                 except Exception as release_err:
                     self.logger.error(f"Error releasing key on focus loss: {release_err}")

            full_cycle_time = self.perf_monitor.stop_timer("full_cycle")
            current_time_mono = time.monotonic()
            if self.app_settings.show_performance_metrics and (current_time_mono - last_perf_log_time >= 5.0):
                if full_cycle_time is not None:
                    fps = self.perf_monitor.get_fps(full_cycle_time)
                    cpu, mem = self.perf_monitor.get_script_resource_usage()
                    self.logger.debug(
                        f"Perf: Cycle={full_cycle_time*1000:.1f}ms (FPS:{fps:.1f}), "
                        f"CPU={cpu if cpu is not None else 'N/A'}%, MEM={f'{mem:.1f}MB' if mem is not None else 'N/A'}. "
                        f"Timings(ms): Find={find_time*1000 if find_time else 'N/A':.1f}, "
                        f"Capture={capture_time*1000 if capture_time else 'N/A':.1f}, "
                        f"Detect={detection_time*1000 if detection_time else 'N/A':.1f}"
                    )
                    self._update_status(f"{current_status_msg} (FPS:{fps:.1f})")
                    last_perf_log_time = current_time_mono

            loop_end_time_mono = time.monotonic()
            elapsed_this_loop = loop_end_time_mono - loop_start_time
            target_loop_delay = 1.0 / self.app_settings.capture_fps if self.app_settings.capture_fps > 0 else 0.1
            sleep_duration = max(0, target_loop_delay - elapsed_this_loop)

            if sleep_duration > 0:
                self.stop_event.wait(timeout=sleep_duration)

        self.logger.info("Detection thread finished.")
        if self.sprint_key_physical_state:
            try:
                self.input_manager.release_key(self.app_settings.sprint_key)
                self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' released on thread exit.")
            except Exception as e:
                self.logger.error(f"Error releasing key on thread exit: {e}")


    def start(self):
        """Starts the system tray application and the detection thread."""
        self.logger.info("Starting SprintManagerApp...")
        icon_image = None
        try:
            app_icon_path_resolved = self.root_dir / self.app_settings.app_icon_path
            if app_icon_path_resolved.is_file():
                icon_image = Image.open(app_icon_path_resolved)
                self.logger.info(f"Loaded application icon: {app_icon_path_resolved}")
            else:
                self.logger.warning(f"App icon not found at {app_icon_path_resolved}, using default.")
        except Exception as e:
            self.logger.exception(f"Error loading application icon '{self.app_settings.app_icon_path}': {e}. Using default icon.")

        self.detection_thread = threading.Thread(target=self.run_detection_logic, daemon=True)
        self.detection_thread.start()

        self.pystray_icon = pystray.Icon(
            "DAOCSprintManager",
            icon=icon_image,
            title="DAOC Sprint Manager",
            menu=self.menu # Use property for dynamic menu
        )
        self._update_status("Running")
        try:
            self.pystray_icon.run() # Blocks until icon.stop() is called
        except Exception as e:
            self.logger.critical(f"Pystray icon run error: {e}", exc_info=True)
            self.stop_event.set() # Ensure detection thread stops
        finally:
            self.logger.info("Pystray icon loop has finished.")
            self.stop_event.set() # Signal thread to stop if not already
            if self.detection_thread and self.detection_thread.is_alive():
                self.logger.info("Waiting for detection thread to join...")
                self.detection_thread.join(timeout=5.0)
                if self.detection_thread.is_alive():
                    self.logger.warning("Detection thread did not cleanly join.")
            self.logger.info("SprintManagerApp fully stopped.")
```
Provided content for `src/daoc_sprint_manager/ui/tray_app.py`.

Finally, the refactored `main.py`.

```python name=src/daoc_sprint_manager/main.py
"""
Main application entry point for the DAOC Sprint Manager.

Initializes configuration, logging, and the system tray application.
"""

import logging
import pathlib
import sys
import os
import threading # For the main app thread if needed, though pystray blocks

# Ensure the project root is added to sys.path for imports if needed
# This makes 'python -m src.daoc_sprint_manager.main' work from project root
# and also helps if 'main.py' is run directly from its directory (though less ideal).
current_file_path = pathlib.Path(__file__).resolve()
# Assuming main.py is in src/daoc_sprint_manager/
# project_root should be daoc_sprint_manager/
# src_root should be daoc_sprint_manager/src/
# module_root should be daoc_sprint_manager/src/daoc_sprint_manager
PROJECT_ROOT_DIR = current_file_path.parent.parent.parent

# Add src to path to allow 'from daoc_sprint_manager...'
SRC_DIR = PROJECT_ROOT_DIR / 'src'
if str(SRC_DIR) not in sys.path:
    sys.path.insert(0, str(SRC_DIR))


try:
    # Attempt to import project modules using the package name
    from daoc_sprint_manager.config_manager import ConfigManager
    from daoc_sprint_manager.data_models import AppSettings
    from daoc_sprint_manager.ui.tray_app import SprintManagerApp, PYSTRAY_AVAILABLE
    from daoc_sprint_manager.utils.logger import setup_logger
except ImportError as e:
    print(f"Import Error: {e}. This script expects to be run in an environment where "
          "the 'daoc_sprint_manager' package is accessible. "
          "Try running with `python -m daoc_sprint_manager.main` from the project root "
          "or ensure PYTHONPATH is set correctly.", file=sys.stderr)
    sys.exit(1)


LOGS_DIR = PROJECT_ROOT_DIR / "logs" # Logs directory in project root

def run_main_application():
    """Initializes and runs the main application logic via the tray app."""
    # --- Preliminary Setup ---
    prelim_log_file = LOGS_DIR / "startup_app.log"
    try:
        LOGS_DIR.mkdir(parents=True, exist_ok=True)
        prelim_logger = setup_logger("startup", prelim_log_file, logging.DEBUG)
        prelim_logger.info(f"Preliminary logging started. Project Root: {PROJECT_ROOT_DIR}")
    except Exception as e:
        print(f"FATAL: Could not set up preliminary logger at {prelim_log_file}: {e}", file=sys.stderr)
        sys.exit(1)

    # --- Configuration Loading ---
    main_logger = prelim_logger
    app_settings: Optional[AppSettings] = None # Initialize to satisfy type checker
    try:
        settings_file = PROJECT_ROOT_DIR / "config" / "settings.json"
        template_file = PROJECT_ROOT_DIR / "config" / "settings.json.template"
        main_logger.info(f"Settings path: {settings_file}")
        main_logger.info(f"Template path: {template_file}")

        config_manager = ConfigManager(settings_file, template_file, main_logger)
        app_settings = config_manager.load_settings()

        # --- Main Logger Setup ---
        actual_log_file_path = LOGS_DIR / app_settings.log_file_name
        log_level_str = app_settings.log_level.upper()
        log_level_int = getattr(logging, log_level_str, logging.INFO) # Default to INFO
        if not isinstance(log_level_int, int): # Check if getattr failed
            main_logger.warning(f"Invalid log level '{app_settings.log_level}' in settings. Defaulting to INFO.")
            log_level_int = logging.INFO
        
        main_logger = setup_logger("DAOCSprintManager", actual_log_file_path, log_level_int)
        main_logger.info("Main application logger initialized.")
        main_logger.info(f"Logging to file: {actual_log_file_path}")
        main_logger.info(f"Log level set to: {logging.getLevelName(main_logger.level)}")

    except Exception as e:
        main_logger.critical(f"Failed during configuration or main logger setup: {e}", exc_info=True)
        sys.exit(1) # Exit if basic setup fails

    # --- Initialize and Start Tray Application ---
    if not PYSTRAY_AVAILABLE:
        main_logger.critical("pystray or Pillow not found. Cannot run system tray application.")
        print("ERROR: pystray or Pillow library not found. Install using: pip install pystray Pillow", file=sys.stderr)
        sys.exit(1)

    main_logger.info("Initializing SprintManagerApp...")
    # Ensure app_settings is not None before passing
    if app_settings is None:
        main_logger.critical("app_settings was not loaded. Exiting.")
        sys.exit(1)
        
    app = SprintManagerApp(app_settings, main_logger, PROJECT_ROOT_DIR)
    main_logger.info("Starting SprintManagerApp...")
    
    # Store app instance in a way that KeyboardInterrupt handler might access it
    # This is a bit of a workaround for direct signal handling by pystray
    _app_instance_holder["app"] = app

    try:
        app.start() # This call blocks until the tray application exits
    except KeyboardInterrupt:
        main_logger.info("KeyboardInterrupt received by main.py during app.start(). Stopping app.")
        if _app_instance_holder["app"]:
            _app_instance_holder["app"]._on_clicked_exit(None, None) # type: ignore
    except Exception as e:
        main_logger.critical(f"Unhandled exception during SprintManagerApp.start(): {e}", exc_info=True)
        if _app_instance_holder["app"]: # Try to gracefully shutdown
            _app_instance_holder["app"]._on_clicked_exit(None, None) # type: ignore
        sys.exit(1)


    # --- Post-Application Run ---
    main_logger.info("Application finished running.")
    return 0

_app_instance_holder = {"app": None} # Global-like holder for app instance

if __name__ == "__main__":
    # Set CWD to project root if running as script for relative paths in config/icon loading
    if not getattr(sys, 'frozen', False): # Not running as a bundled exe
        try:
            os.chdir(PROJECT_ROOT_DIR)
            print(f"Successfully changed CWD to: {os.getcwd()}")
        except Exception as e:
            print(f"Warning: Could not change CWD to project root ({PROJECT_ROOT_DIR}): {e}")
    else: # Running as bundled exe
        # For PyInstaller, PROJECT_ROOT_DIR might be sys._MEIPASS or executable's dir
        # Ensure this is handled correctly if resources are bundled.
        # For now, we assume PROJECT_ROOT_DIR as defined points to the right place.
        print(f"Running as bundled app. Effective ROOT_DIR: {PROJECT_ROOT_DIR}")


    # Setup basic logging immediately for __main__ block
    initial_logger = logging.getLogger("main_entry_point")
    initial_logger.setLevel(logging.INFO)
    if not initial_logger.handlers:
        initial_handler = logging.StreamHandler(sys.stdout)
        initial_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        initial_handler.setFormatter(initial_formatter)
        initial_logger.addHandler(initial_handler)

    exit_code = 1 # Default to error
    try:
        exit_code = run_main_application()
        if exit_code == 0:
            initial_logger.info("Application run completed successfully.")
        else:
            initial_logger.error(f"Application run exited with error code: {exit_code}")

    except KeyboardInterrupt:
        initial_logger.info("KeyboardInterrupt received in __main__. Application should be stopping via tray app.")
        # The SprintManagerApp's exit handler should manage cleanup.
        # Pystray usually handles SIGINT; if not, the app.start() try-except should catch it.
        if _app_instance_holder["app"]:
            app_instance = _app_instance_holder["app"]
            if app_instance.pystray_icon and not app_instance.stop_event.is_set():
                initial_logger.info("Manually triggering app exit due to KeyboardInterrupt in __main__.")
                app_instance._on_clicked_exit(None, None) # type: ignore
        exit_code = 0
    except Exception as e:
        initial_logger.critical(f"Critical unhandled exception in __main__ execution: {e}", exc_info=True)
        if _app_instance_holder["app"]: # Try to gracefully shutdown
            app_instance = _app_instance_holder["app"]
            if app_instance.pystray_icon and not app_instance.stop_event.is_set():
                app_instance._on_clicked_exit(None, None) # type: ignore
        exit_code = 1
    finally:
        initial_logger.info("Main execution block finished.")
        logging.shutdown() # Ensure all handlers are flushed
        print("Main Python script shutdown complete.")
        sys.exit(exit_code)
```
Provided content for `src/daoc_sprint_manager/main.py`.

And here is the user task reminder:
```
User Task: Provide an application icon named 'app_icon.png' (e.g., 32x32 or 64x64 pixels) in the 'PythonSprint/data/' directory. This icon will be used for the system tray. The path is also configurable in settings.json.template as app_icon_path.
```

All Phase 2 files have been provided. The conceptual memory bank and documentation are updated to reflect the completion of Phase 2.

This is an ideal time to transition context to a new session agent.

---

**Handoff Prompt for Next AI Agent (Gemini 2.5 Pro Orchestrator)**

```text
# DAOC Sprint Manager - Project Handoff: Start Phase 3

## Project Overview & Current Status
You are the **Orchestrator AI (Gemini 2.5 Pro)** for the "DAOC Sprint Manager" project. This Python application automates sprint buff management in Dark Age of Camelot.
- **Phase 1 (Foundation & Basic Detection)**: COMPLETE.
- **Phase 2 (Advanced Detection & Input System)**: COMPLETE. This included temporal consistency in detection, keyboard input management via pydirectinput, performance monitoring, and a basic system tray UI using pystray. The application can successfully identify the game window, capture ROI, detect sprint icon with temporal consistency, simulate key presses based on game window focus, and provides a system tray icon for basic control (Pause/Resume, Open Config, Exit).
- **Current State**: The application is functional with a system tray UI.

## Your Current Task: Initiate and Oversee Phase 3
You will now begin **Phase 3: Robustness & ML Implementation (Optional)** as detailed in the `PythonSprintPlan.md`. Your immediate task is to implement **Phase 3, Step 1: ML-Based Icon Detection**.

## Phase 3, Step 1: ML-Based Icon Detection - Detailed Instructions

Follow these steps meticulously, adhering to all Universal Code Quality and Architectural Standards outlined in `PythonSprintPlan.md`:

1.  **Update `PythonSprint/requirements.txt`**: Add `onnxruntime` to the project dependencies.
2.  **Output User Task Reminder**: Provide the "ML Model User Task" text exactly as specified in the plan. This text guides the human user on manual tasks related to dataset collection and model training for the ML feature.
3.  **Update Data Models and Configuration Template**:
    *   Modify `PythonSprint/src/daoc_sprint_manager/data_models.py`: Add `ml_model_path: str`, `ml_input_size_wh: list[int]`, and `ml_confidence_threshold: float` to the `AppSettings` dataclass with their specified default values.
    *   Modify `PythonSprint/config/settings.json.template`: Add the corresponding keys and default values for these new ML settings.
4.  **Implement `MLDetector` Class**:
    *   Create a new file: `PythonSprint/src/daoc_sprint_manager/core/ml_detector.py`.
    *   Implement the `MLDetector` class with the structure and methods (`__init__`, `_preprocess_image`, `predict`) precisely as defined in `PythonSprintPlan.md`.
    *   Include an `if __name__ == "__main__":` block for self-testing. This test will require a dummy ONNX model and a dummy image. Provide clear instructions within the self-test comments on how a user should create/place these dummy files for the test to be runnable.

5.  **Deliverables**:
    *   Full content of `PythonSprint/src/daoc_sprint_manager/core/ml_detector.py`.
    *   Updated content of `PythonSprint/src/daoc_sprint_manager/data_models.py`.
    *   Updated content of `PythonSprint/config/settings.json.template`.
    *   Updated content of `PythonSprint/requirements.txt`.

## Development Guidelines & Tools

*   **Primary Reference**: The `PythonSprintPlan.md` document.
*   **Quality Standards**: Enforce PEP 8, type hinting, Google Style docstrings, robust error handling, and module self-tests.
*   **File Operations**: Use `pathlib.Path`.
*   **Encoding**: Specify `encoding='utf-8'` for file operations.
*   **MCP Tools**: Use `read_file`, `edit_file`, `create_file` for file operations. Provide complete, runnable code for the entire file when editing or creating.
*   **Memory Bank**: All previously generated files (Phase 1 & 2 deliverables) and the `PythonSprintPlan.md` are considered part of the Memory Bank.
*   **Iterative Approach**: Implement each sub-task sequentially.

## Starting Point
Begin by updating `PythonSprint/requirements.txt`. Then, provide the "ML Model User Task Reminder" output. After that, update `data_models.py` and `config/settings.json.template`. Finally, implement the `MLDetector` class.

**After completing all deliverables for Phase 3, Step 1, explicitly state "Phase 3, Step 1 deliverables complete." and await further instructions.**
```

---

_**Assistant**_



---

Looking at your TASK.md file, I'll help you integrate ONNX Runtime for ML-based detection (Task 2.1). This will allow your application to use machine learning models as an alternative to template matching for more reliable sprint icon detection.

---

<details>
            <summary>Searched codebase "requirements.txt" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `requirements.txt` | L1-9 |
| `ASMS-DAOC/src/python/requirements.txt` | L1-3 |
| `.specstory/history/2025-05-08_13-12-debugging-asms-daoc-sprint-detection-issues.md` | L5128-5177 |
| `ASMS-DAOC/src/python/README.md` | L1-42 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L9788-9842 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L7037-7093 |
| `PythonSprint/PythonSprintPlan.md` | L38-57 |
| `ASMS-DAOC/RunDataCaptureTool.bat` | L1-35 |
| `PythonSprint/PythonSprintPlan.md` | L492-535 |
| `ASMS-DAOC/src/python/test_setup.py` | L25-58 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L76-205 |
| `README.md` | L1-61 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L205-262 |
| `README.md` | L131-158 |
| `ASMS-DAOC/docs/Installation.md` | L1-59 |
| `.specstory/history/2025-05-07_23-26-autonomous-sprint-management-system-development.md` | L2047-2138 |
| `ASMS-DAOC/installer/README.md` | L1-45 |
| `PythonSprint/PythonSprintPlan.md` | L57-90 |
| `PythonSprint/PythonSprintPlan.md` | L556-577 |
| `src/daoc_sprint_manager/utils/roi_helper.py` | L1-39 |
| `PythonSprint/PythonSprintPlan.md` | L535-556 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L6637-6724 |
| `ASMS-DAOC/docs/User_Guide.md` | L1-54 |
| `PythonSprint/PythonSprintPlan.md` | L382-391 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L9663-9721 |

</details>

---

Let's find the data_models.py file to understand the current structure before adding ML settings:

---

<details>
            <summary>Searched codebase "data_models.py AppSettings" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/daoc_sprint_manager/data_models.py` | L166-200 |
| `src/daoc_sprint_manager/data_models.py` | L33-90 |
| `src/daoc_sprint_manager/data_models.py` | L90-140 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L5232-5288 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L423-468 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L353-380 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L380-423 |
| `src/daoc_sprint_manager/data_models.py` | L140-166 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L5342-5384 |
| `PythonSprint/PythonSprintPlan.md` | L99-109 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L506-542 |
| `src/daoc_sprint_manager/data_models.py` | L1-33 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L468-506 |
| `src/daoc_sprint_manager/data_models.py` | L200-223 |
| `.specstory/history/2025-05-09_03-44-untitled.md` | L776-814 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L542-568 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L5681-5726 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L2891-2939 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L10862-10912 |
| `src/daoc_sprint_manager/config_manager.py` | L112-152 |
| `src/daoc_sprint_manager/ui/tray_app.py` | L1-46 |
| `src/daoc_sprint_manager/config_manager.py` | L1-45 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L5183-5232 |
| `PythonSprint/PythonSprintPlan.md` | L109-125 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L2079-2116 |

</details>

---

Let's check the settings.json.template file to understand what needs to be updated:

---

<details>
            <summary>Searched codebase "settings.json.template" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/daoc_sprint_manager/config/settings.json.template` | L1-19 |
| `capture/capture_settings.ahk` | L99-141 |
| `src/daoc_sprint_manager/config/settings.json` | L1-19 |
| `.specstory/history/2025-05-08_11-06-asms-daoc-installer-development-and-finalization.md` | L2192-2241 |
| `config/settings.json` | L1-13 |
| `ASMS-DAOC/config/settings.json` | L1-2 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L205-262 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L595-626 |
| `.specstory/history/2025-05-08_09-39-asms-daoc-project-final-release-preparation.md` | L1120-1149 |
| `capture/capture_settings.ahk` | L1-52 |
| `PythonSprint/PythonSprintPlan.md` | L125-154 |
| `capture/capture_settings.ahk` | L178-221 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L6881-6946 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L9842-9898 |
| `.specstory/history/2025-05-08_09-39-asms-daoc-project-final-release-preparation.md` | L1081-1120 |
| `ASMS-DAOC/AlwaysSprint_enhanced.ahk` | L314-344 |
| `AlwaysSprint.ahk` | L1-55 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L6225-6283 |
| `ASMS-DAOC/AlwaysSprint_enhanced.ahk` | L1367-1397 |
| `capture/capture_settings.ahk` | L221-271 |
| `.specstory/history/2025-05-08_13-12-debugging-asms-daoc-sprint-detection-issues.md` | L1159-1201 |
| `README.md` | L61-131 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L5288-5342 |
| `.specstory/history/2025-05-08_13-12-debugging-asms-daoc-sprint-detection-issues.md` | L1510-1562 |
| `.specstory/history/2025-05-08_19-20-python-project-setup-for-daoc-sprint-manager.md` | L468-506 |

</details>

---

Now I need to see what Python files exist in the project structure to understand where to add the ML detector:

---

<details>
            <summary>Listed directory src/daoc_sprint_manager/core • **4** results</summary>
        
| Name |
|-------|
| 📄 `__init__.py` |
| 📄 `window_manager.py` |
| 📄 `icon_detector.py` |
| 📄 `input_manager.py` |

</details>

---

Let's check the current requirements.txt file:

---

Read file: requirements.txt

---

Based on my investigation, I'll now implement all required changes for the ONNX integration. Let's start with updating the requirements.txt file:

---

```diff
  psutil>=5.8.0
  pydantic>=1.9.0
+ onnxruntime>=1.14.0 
```

---

Now, let's update the data_models.py file to add the ML-related settings:

---

Read file: src/daoc_sprint_manager/data_models.py

---

Now, let's edit the data_models.py file to add the ML-related settings:

---

```diff
      )
      
-     @validator('template_match_threshold')
-     def validate_threshold(cls, v):
-         """Validate that the threshold is within the valid range."""
+     # ML Detection Settings
+     ml_model_path: str = Field(
+         "data/models/sprint_classifier.onnx", 
+         description="Path to the ONNX ML model file, relative to the project root."
+     )
+     ml_input_size_wh: List[int] = Field(
+         [32, 32], 
+         description="Required input size for the ML model as [width, height] in pixels."
+     )
+     ml_confidence_threshold: float = Field(
+         0.7, 
+         description="Confidence threshold for ML detection (0.0-1.0). Higher values require higher confidence."
+     )
+     
+     @validator('template_match_threshold', 'ml_confidence_threshold')
+     def validate_threshold(cls, v, values, **kwargs):
+         """Validate that the thresholds are within the valid range."""
          if not 0.0 <= v <= 1.0:
-             raise ValueError("Template match threshold must be between 0.0 and 1.0")
+             raise ValueError("Threshold values must be between 0.0 and 1.0")
          return v
          
          return v.upper()
          
+     @validator('ml_input_size_wh')
+     def validate_ml_input_size(cls, v):
+         """Validate ML input size format and values."""
+         if not isinstance(v, list) or len(v) != 2:
+             raise ValueError("ML input size must be a list of exactly 2 integers [width, height]")
+         if v[0] <= 0 or v[1] <= 0:
+             raise ValueError("ML input dimensions must be positive")
+         return v
+         
      def __post_init__(self):
          """Perform additional validation and logging if pydantic is not available."""
              if not 0.0 <= getattr(self, 'template_match_threshold', 0.0) <= 1.0:
                  raise ValueError("Template match threshold must be between 0.0 and 1.0")
+             if not 0.0 <= getattr(self, 'ml_confidence_threshold', 0.0) <= 1.0:
+                 raise ValueError("ML confidence threshold must be between 0.0 and 1.0")
              if getattr(self, 'temporal_consistency_frames', 0) < 1:
                  raise ValueError("Temporal consistency frames must be at least 1")
      print(f"Template threshold: {default_settings.template_match_threshold}")
      print(f"Consistency frames: {default_settings.temporal_consistency_frames}")
+     print(f"ML model path: {default_settings.ml_model_path}")
+     print(f"ML input size: {default_settings.ml_input_size_wh}")
+     print(f"ML threshold: {default_settings.ml_confidence_threshold}")
      
      # Test creating with custom values
          template_match_threshold=0.9,
          temporal_consistency_frames=5,
-         log_level="DEBUG"
+         log_level="DEBUG",
+         ml_input_size_wh=[64, 64],
+         ml_confidence_threshold=0.85
      )
      print(f"Game window title: {custom_settings.game_window_title}")
      print(f"Consistency frames: {custom_settings.temporal_consistency_frames}")
      print(f"Log level: {custom_settings.log_level}")
+     print(f"ML input size: {custom_settings.ml_input_size_wh}")
+     print(f"ML threshold: {custom_settings.ml_confidence_threshold}")
      
      # Test JSON serialization if pydantic is available
          except ValueError as e:
              print(f"✅ Expected validation error: {e}")
+             
+         # Test ML-specific validation
+         print("\nTesting ML validation:")
+         try:
+             invalid_ml_settings = AppSettings(ml_input_size_wh=[0, 32])
+             print("❌ ML validation should have failed but didn't")
+         except ValueError as e:
+             print(f"✅ Expected ML validation error: {e}")
      else:
          print("\nPydantic not available, skipping JSON serialization tests")
```

---

Now let's update the settings.json.template file:

---

Could not find file 'config/settings.json.template'. Did you mean one of:
- src/daoc_sprint_manager/config/settings.json.template

---

Let's read the correct file:

---

Read file: src/daoc_sprint_manager/config/settings.json.template

---

Now let's update the settings.json.template file:

---

```diff
    "log_level": "INFO",
    "log_file_name": "daoc_sprint_manager.log",
-   "app_icon_path": "data/app_icon.png"
+   "app_icon_path": "data/app_icon.png",
+   "ml_model_path": "data/models/sprint_classifier.onnx",
+   "ml_input_size_wh": [32, 32],
+   "ml_confidence_threshold": 0.7
  } 
```

---

Now, let's create the MLDetector class:

---

```diff
- 
+ """
+ Machine learning-based icon detector using ONNX Runtime.
+ 
+ This module provides functionality to use an ONNX model for 
+ detecting icon states in the game interface.
+ """
+ 
+ import logging
+ import pathlib
+ from typing import List, Optional, Tuple, Union
+ 
+ import cv2
+ import numpy as np
+ 
+ try:
+     import onnxruntime as ort
+     ONNXRUNTIME_AVAILABLE = True
+ except ImportError:
+     ONNXRUNTIME_AVAILABLE = False
+ 
+ 
+ class MLDetector:
+     """
+     Detects icon states using an ONNX ML model.
+     
+     This class loads and runs inference with an ONNX model to determine the state
+     of the sprint icon in captured frames from the game.
+     """
+     
+     def __init__(
+         self,
+         model_path: pathlib.Path,
+         input_size_wh: List[int],
+         confidence_threshold: float,
+         logger: logging.Logger
+     ):
+         """
+         Initialize the ML detector.
+         
+         Args:
+             model_path: Path to the ONNX model file.
+             input_size_wh: Required input dimensions [width, height] for the model.
+             confidence_threshold: Confidence threshold for positive detection (0.0-1.0).
+             logger: Logger instance for recording operations and errors.
+         
+         Raises:
+             ImportError: If onnxruntime is not installed.
+             ValueError: If model_path is invalid or model can't be loaded.
+         """
+         self.logger = logger
+         self.input_size_wh = input_size_wh
+         self.confidence_threshold = confidence_threshold
+         
+         if not ONNXRUNTIME_AVAILABLE:
+             self.logger.error("MLDetector initialization failed: onnxruntime not installed")
+             raise ImportError(
+                 "The onnxruntime package is required for ML-based detection. "
+                 "Install it using: pip install onnxruntime"
+             )
+         
+         if not model_path.exists():
+             self.logger.error(f"Model file does not exist: {model_path}")
+             raise ValueError(f"ONNX model not found at {model_path}")
+         
+         try:
+             # Create an ONNX inference session
+             self.logger.info(f"Loading ONNX model from {model_path}")
+             self.session = ort.InferenceSession(
+                 str(model_path),
+                 providers=['CPUExecutionProvider']  # Use CPU provider by default for compatibility
+             )
+             
+             # Get input details
+             model_inputs = self.session.get_inputs()
+             if not model_inputs:
+                 raise ValueError("Model has no inputs")
+             
+             self.input_name = model_inputs[0].name
+             expected_shape = model_inputs[0].shape
+             
+             # Check if the shape is compatible
+             if len(expected_shape) != 4:  # [batch, channels, height, width]
+                 self.logger.warning(
+                     f"Model input shape {expected_shape} is not the expected NCHW format. "
+                     "This might cause prediction errors."
+                 )
+             
+             # Get output details
+             model_outputs = self.session.get_outputs()
+             if not model_outputs:
+                 raise ValueError("Model has no outputs")
+             
+             self.output_name = model_outputs[0].name
+             self.logger.info(
+                 f"Model loaded successfully. Input: {self.input_name}, Output: {self.output_name}"
+             )
+             
+         except Exception as e:
+             self.logger.error(f"Error initializing ONNX model: {e}", exc_info=True)
+             raise ValueError(f"Failed to initialize ONNX model: {e}")
+     
+     def _preprocess_image(self, image: np.ndarray) -> np.ndarray:
+         """
+         Preprocess the input image for the ML model.
+         
+         Args:
+             image: Input image in BGR format (OpenCV default).
+             
+         Returns:
+             Preprocessed image as a numpy array ready for inference.
+         """
+         if image.size == 0:
+             self.logger.error("Empty image passed to preprocessing")
+             raise ValueError("Input image is empty")
+         
+         try:
+             # Resize to required input dimensions
+             resized = cv2.resize(
+                 image,
+                 (self.input_size_wh[0], self.input_size_wh[1]),
+                 interpolation=cv2.INTER_AREA
+             )
+             
+             # Convert BGR to RGB
+             rgb = cv2.cvtColor(resized, cv2.COLOR_BGR2RGB)
+             
+             # Normalize to 0-1 range and convert to float32
+             normalized = rgb.astype(np.float32) / 255.0
+             
+             # Move channel dimension to correct position (NCHW format)
+             # From (height, width, channels) to (1, channels, height, width)
+             transposed = np.transpose(normalized, (2, 0, 1))
+             batched = np.expand_dims(transposed, axis=0)
+             
+             return batched
+             
+         except Exception as e:
+             self.logger.error(f"Error preprocessing image: {e}", exc_info=True)
+             raise ValueError(f"Image preprocessing failed: {e}")
+     
+     def predict(self, image: np.ndarray) -> Tuple[bool, float]:
+         """
+         Perform ML inference on the input image to detect the sprint icon state.
+         
+         Args:
+             image: Input image in BGR format (OpenCV default).
+             
+         Returns:
+             Tuple of (is_detected, confidence_score):
+             - is_detected: True if icon is detected with confidence above threshold.
+             - confidence_score: The model's confidence value (0.0-1.0).
+             
+         Raises:
+             ValueError: If inference fails or returns invalid results.
+         """
+         if image is None or image.size == 0:
+             self.logger.error("Invalid image passed to predict method")
+             return False, 0.0
+         
+         try:
+             # Preprocess the image
+             preprocessed = self._preprocess_image(image)
+             
+             # Run inference
+             inputs = {self.input_name: preprocessed}
+             outputs = self.session.run([self.output_name], inputs)
+             
+             if not outputs or len(outputs[0]) == 0:
+                 self.logger.error("Model returned empty output")
+                 return False, 0.0
+             
+             # Parse the output - assuming a binary classification model
+             # Output shape is typically [1, 2] or [1, 1] depending on model architecture
+             raw_output = outputs[0]
+             
+             # Handle different output formats
+             confidence_score = 0.0
+             
+             if raw_output.shape[-1] == 2:
+                 # If output has two values (typical softmax output [not_detected, detected])
+                 confidence_score = float(raw_output[0, 1])  # Second value represents "detected" class
+             elif raw_output.shape[-1] == 1:
+                 # If output has a single value (sigmoid output for binary classification)
+                 confidence_score = float(raw_output[0, 0])
+             else:
+                 # For other cases, take the maximum value
+                 confidence_score = float(np.max(raw_output))
+             
+             # Apply confidence threshold
+             is_detected = confidence_score >= self.confidence_threshold
+             
+             self.logger.debug(
+                 f"ML prediction: {'Detected' if is_detected else 'Not detected'} "
+                 f"with confidence {confidence_score:.4f}"
+             )
+             
+             return is_detected, confidence_score
+             
+         except Exception as e:
+             self.logger.error(f"Error during ML inference: {e}", exc_info=True)
+             return False, 0.0
+ 
+ 
+ if __name__ == "__main__":
+     """
+     Self-test for the MLDetector.
+     
+     To run this test, you must have a sample ONNX model and a test image.
+     The test will look for:
+     - A dummy ONNX model at 'tests/data/models/dummy_model.onnx'
+     - A test image at 'tests/data/images/test_icon.png'
+     
+     You can create a dummy ONNX model with these steps:
+     1. Install required packages: pip install onnx onnxruntime tensorflow tensorflow_addons
+     2. Use a script like this to create a simple classification model:
+     
+     ```python
+     import tensorflow as tf
+     import onnx
+     import tf2onnx
+     import numpy as np
+     import os
+     
+     # Create a simple model
+     model = tf.keras.Sequential([
+         tf.keras.layers.Input(shape=(32, 32, 3)),
+         tf.keras.layers.Conv2D(16, (3, 3), activation='relu', padding='same'),
+         tf.keras.layers.MaxPooling2D((2, 2)),
+         tf.keras.layers.Flatten(),
+         tf.keras.layers.Dense(64, activation='relu'),
+         tf.keras.layers.Dense(2, activation='softmax') # Binary classifier
+     ])
+     
+     # Compile the model
+     model.compile(optimizer='adam', loss='categorical_crossentropy')
+     
+     # Create output directory
+     os.makedirs("tests/data/models", exist_ok=True)
+     
+     # Convert the model to ONNX
+     input_signature = [tf.TensorSpec([1, 32, 32, 3], tf.float32, name='input')]
+     onnx_model, _ = tf2onnx.convert.from_keras(model, input_signature, opset=13)
+     onnx.save(onnx_model, "tests/data/models/dummy_model.onnx")
+     
+     print("Dummy ONNX model created at: tests/data/models/dummy_model.onnx")
+     ```
+     
+     3. Create a test image at 'tests/data/images/test_icon.png' (32x32 pixel)
+     """
+     import os
+     import sys
+     
+     # Setup basic logging
+     test_logger = logging.getLogger("MLDetectorTest")
+     test_logger.setLevel(logging.DEBUG)
+     handler = logging.StreamHandler(sys.stdout)
+     handler.setFormatter(
+         logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+     )
+     test_logger.addHandler(handler)
+     
+     # Create test directories if they don't exist
+     test_dirs = ['tests/data/models', 'tests/data/images']
+     for directory in test_dirs:
+         os.makedirs(directory, exist_ok=True)
+     
+     print("\n--- Testing MLDetector Class ---")
+     
+     if not ONNXRUNTIME_AVAILABLE:
+         print("ERROR: onnxruntime not installed. Please install with: pip install onnxruntime")
+         sys.exit(1)
+     
+     # Define test paths
+     test_model_path = pathlib.Path("tests/data/models/dummy_model.onnx")
+     test_image_path = pathlib.Path("tests/data/images/test_icon.png")
+     
+     # Check if test files exist
+     model_exists = test_model_path.exists()
+     image_exists = test_image_path.exists()
+     
+     if not model_exists:
+         print(f"WARNING: Test model not found at {test_model_path}")
+         print("Please create a dummy model following the instructions in the comments.")
+         
+     if not image_exists:
+         print(f"WARNING: Test image not found at {test_image_path}")
+         print("Creating a blank test image...")
+         import numpy as np
+         import cv2
+         # Create a 32x32 test image with a white circle
+         test_image = np.zeros((32, 32, 3), dtype=np.uint8)
+         cv2.circle(test_image, (16, 16), 10, (255, 255, 255), -1)
+         os.makedirs(test_image_path.parent, exist_ok=True)
+         cv2.imwrite(str(test_image_path), test_image)
+         print(f"Created test image at {test_image_path}")
+         image_exists = True
+     
+     # Run tests only if we have both the model and image
+     if model_exists and image_exists:
+         try:
+             # Initialize MLDetector
+             print("\nTest 1: Initializing MLDetector...")
+             detector = MLDetector(
+                 model_path=test_model_path,
+                 input_size_wh=[32, 32],
+                 confidence_threshold=0.5,
+                 logger=test_logger
+             )
+             print("✅ MLDetector initialized successfully")
+             
+             # Test prediction
+             print("\nTest 2: Testing prediction...")
+             test_image = cv2.imread(str(test_image_path))
+             if test_image is None:
+                 print(f"❌ Failed to load test image from {test_image_path}")
+             else:
+                 is_detected, confidence = detector.predict(test_image)
+                 print(f"Prediction result: {'Detected' if is_detected else 'Not detected'}")
+                 print(f"Confidence score: {confidence:.4f}")
+                 print("✅ Prediction completed")
+                 
+             print("\nAll tests with mock data completed successfully")
+             
+         except Exception as e:
+             print(f"❌ Test failed with error: {e}")
+     else:
+         print("\nSkipping tests that require model and image files.")
+         
+     # Test proper error handling
+     print("\nTest 3: Testing error handling...")
+     
+     # Test with non-existent model file
+     try:
+         nonexistent_model = pathlib.Path("nonexistent_model.onnx")
+         MLDetector(
+             model_path=nonexistent_model,
+             input_size_wh=[32, 32],
+             confidence_threshold=0.5,
+             logger=test_logger
+         )
+         print("❌ Should have raised ValueError for non-existent model")
+     except ValueError as e:
+         print(f"✅ Correctly caught ValueError: {e}")
+     except Exception as e:
+         print(f"❓ Expected ValueError but got: {e}")
+     
+     print("\n--- MLDetector Tests Complete ---") 
```

---

Let me provide a user task reminder for collecting training data and generating an ML model:

The ML-Based Detection feature requires a trained ONNX model to detect sprint icons. Here's what you need to do:

## ML Model User Task

To prepare for using the ML-based detection feature:

1. **Create a data collection directory structure**:
   ```
   data/
   ├── model_training/
   │   ├── active/     # Screenshots with sprint active
   │   └── inactive/   # Screenshots with sprint inactive
   ├── models/         # Directory for the final ONNX model
   ```

2. **Collect training data**:
   - Run the game and capture screenshots of the sprint icon area in different states
   - Save at least 20-30 images for each state (active/inactive)
   - Include variations in lighting, UI scale, and conditions
   - Images should be cropped to include just the icon area

3. **Train a simple classifier model**:
   - You can use a tool like TensorFlow or PyTorch
   - Export the model to ONNX format with the name `sprint_classifier.onnx`
   - The model should accept a 32x32 pixel RGB image and output a binary classification

4. **Place the model in the correct location**:
   - Put the exported ONNX model in `data/models/sprint_classifier.onnx`
   - Update `settings.json` if needed to point to the model location

5. **If you need help training a model**:
   - Simple script templates for this purpose can be found in the comments of `ml_detector.py`
   - You can also use simplified tools like TensorFlow's Model Maker or PyTorch's torchvision for transfer learning

Once these steps are completed, the application will be able to use ML-based detection as a more robust alternative to template matching.

## Phase 3, Step 1 deliverables complete

I've completed all the required deliverables for Phase 3, Step 1:

1. Added `onnxruntime>=1.14.0` to requirements.txt
2. Added ML settings to data_models.py with validation:
   - `ml_model_path` 
   - `ml_input_size_wh`
   - `ml_confidence_threshold`
3. Updated settings.json.template with default ML settings
4. Created ml_detector.py with:
   - Proper imports and error handling for missing dependencies
   - Implementation of MLDetector class with initialization, preprocessing, and prediction
   - Self-test code and instructions for creating test files

The implementation includes:
- Graceful fallback if ONNX Runtime is not available
- Comprehensive error handling
- Input preprocessing for ML models (resizing, normalization, format conversion)
- Support for different model output formats
- Detailed logging
- Type hints and docstrings

Is there anything specific you'd like me to explain about the implementation?

---

_**User**_

Here are some Project Code Deliverabbles Corrected from the orchestrator. Can you make sure this is correct and integrate anything that mayy be existing in our current project:

You are absolutely correct! My apologies. My previous responses were generating the code and text as if I were performing the actions, but I was not actually creating or modifying files in *your* project environment. I was simulating the output based on the plan.

Let's rectify this. I will now provide the **complete and final content** for each file delivered in Phase 2. Please use this content to create or replace the files in your `PythonSprint` project directory.

**Phase 2: Advanced Detection & Input System - Completed Deliverables**

First, I'll provide the updated `icon_detector.py` which includes the temporal consistency logic.

```python name=src/daoc_sprint_manager/core/icon_detector.py
"""
Provides functionality for detecting icons in images using template matching
and temporal consistency checks.
"""

import logging
import pathlib
from collections import deque
from typing import Deque, Optional, Tuple

import cv2
import numpy as np


class IconDetector:
    """
    Detects icons in images using template matching and temporal consistency.

    This class provides functionality to load template images, detect them
    within captured frames using OpenCV's template matching, and apply
    temporal consistency logic to confirm detection state changes.
    """

    def __init__(self, logger: logging.Logger, temporal_consistency_frames: int):
        """
        Initialize the IconDetector.

        Args:
            logger: Logger instance for recording operations and errors.
            temporal_consistency_frames: The number of consecutive frames
                required with the same detection status to confirm a state change.
        """
        self.logger = logger
        self.temporal_consistency_frames = max(1, temporal_consistency_frames) # Ensure at least 1 frame
        self.detection_history: Deque[bool] = deque(maxlen=self.temporal_consistency_frames)
        self.confirmed_detection_state: bool = False  # Assume icon is initially 'off' or not detected
        self.logger.debug(
            f"IconDetector initialized with temporal consistency "
            f"frames: {self.temporal_consistency_frames}"
        )

    def load_template(self, template_path: pathlib.Path) -> Optional[np.ndarray]:
        """
        Load a template image from the specified path.

        Args:
            template_path: Path to the template image file (should be a PNG without alpha).

        Returns:
            NumPy array containing the template image in BGR format, or None if loading fails.
        """
        try:
            if not template_path.exists():
                self.logger.error(f"Template file does not exist: {template_path}")
                return None

            if not template_path.is_file():
                self.logger.error(f"Template path is not a file: {template_path}")
                return None

            template = cv2.imread(str(template_path), cv2.IMREAD_COLOR)

            if template is None:
                self.logger.error(f"Failed to load template image: {template_path} (cv2.imread returned None)")
                return None

            if template.size == 0 or template.shape[0] == 0 or template.shape[1] == 0:
                self.logger.error(f"Loaded template has invalid dimensions: {template_path}, shape={template.shape}")
                return None

            self.logger.info(f"Successfully loaded template: {template_path}, shape={template.shape}")
            return template

        except cv2.error as e:
            self.logger.error(f"OpenCV error loading template {template_path}: {e}")
            return None
        except Exception as e:
            self.logger.exception(f"Unexpected error loading template {template_path}: {e}")
            return None

    def detect_icon(
        self,
        frame: np.ndarray,
        template: np.ndarray,
        threshold: float
    ) -> Tuple[bool, float, Optional[Tuple[int, int, int, int]]]:
        """
        Detect a template image within a frame using template matching.

        Args:
            frame: The image to search within (BGR format).
            template: The template to search for (BGR format).
            threshold: Confidence threshold (0.0-1.0) for detection.

        Returns:
            Tuple containing:
            - bool: Whether the icon was found (confidence >= threshold)
            - float: Confidence score (0.0-1.0)
            - Optional[Tuple[int, int, int, int]]: Bounding box (x, y, w, h) if found, None otherwise.
        """
        if frame is None:
            self.logger.error("Cannot detect icon, input frame is None.")
            return False, 0.0, None
        if template is None:
            self.logger.error("Cannot detect icon, template is None.")
            return False, 0.0, None
        if not isinstance(frame, np.ndarray):
             self.logger.error(f"Invalid frame type: {type(frame)}. Expected numpy array.")
             return False, 0.0, None
        if not isinstance(template, np.ndarray):
             self.logger.error(f"Invalid template type: {type(template)}. Expected numpy array.")
             return False, 0.0, None
        if frame.ndim < 2 or template.ndim < 2: # Basic check for valid image arrays
            self.logger.error(f"Frame or template has invalid dimensions: frame={frame.shape}, template={template.shape}")
            return False, 0.0, None

        try:
            frame_height, frame_width = frame.shape[:2]
            template_height, template_width = template.shape[:2]

            if template_width <= 0 or template_height <= 0:
                 self.logger.error(f"Template has zero or negative dimension: {template_width}x{template_height}")
                 return False, 0.0, None
            if frame_width <= 0 or frame_height <= 0:
                 self.logger.error(f"Frame has zero or negative dimension: {frame_width}x{frame_height}")
                 return False, 0.0, None

            if template_width > frame_width or template_height > frame_height:
                self.logger.error(
                    f"Template dimensions ({template_width}x{template_height}) "
                    f"exceed frame dimensions ({frame_width}x{frame_height}). Cannot perform match."
                )
                return False, 0.0, None

            result = cv2.matchTemplate(frame, template, cv2.TM_CCOEFF_NORMED)
            _minVal, maxVal, _minLoc, max_loc = cv2.minMaxLoc(result)
            confidence_score = float(maxVal)

            found = confidence_score >= threshold

            if found:
                location_rect = (max_loc[0], max_loc[1], template_width, template_height)
                self.logger.debug(
                    f"Raw icon detection: found=True, confidence={confidence_score:.4f} (>= {threshold:.2f}), "
                    f"location={location_rect}"
                )
            else:
                location_rect = None
                self.logger.debug(
                    f"Raw icon detection: found=False, confidence={confidence_score:.4f} (< {threshold:.2f})"
                )

            return found, confidence_score, location_rect

        except cv2.error as e:
            self.logger.error(f"OpenCV error during template matching: {e}")
            return False, 0.0, None
        except Exception as e:
            self.logger.exception(f"Unexpected error during template matching: {e}")
            return False, 0.0, None

    def update_consistent_detection_state(self, current_frame_found: bool) -> bool:
        """
        Updates the detection history and determines the confirmed detection state.

        Adds the current frame's detection result to a history buffer.
        A confirmed state change only occurs if the buffer is full and all
        entries in the buffer are consistently True or consistently False.

        Args:
            current_frame_found: Whether the icon was detected in the current frame.

        Returns:
            The confirmed detection state (True if consistently detected, False otherwise).
        """
        self.detection_history.append(current_frame_found)
        self.logger.debug(f"Detection history updated. Current raw detection: {current_frame_found}. History: {list(self.detection_history)}")

        if len(self.detection_history) < self.detection_history.maxlen:
            # Buffer not full yet, maintain current confirmed state
            self.logger.debug(f"Detection history buffer not full ({len(self.detection_history)}/{self.detection_history.maxlen}). Confirmed state remains: {self.confirmed_detection_state}")
            return self.confirmed_detection_state

        # Check for consistent state only when buffer is full
        all_true_in_history = all(self.detection_history)
        all_false_in_history = not any(self.detection_history)

        previous_confirmed_state = self.confirmed_detection_state

        if all_true_in_history:
            self.confirmed_detection_state = True
            if previous_confirmed_state is False: # Log only on change
                 self.logger.info("Confirmed detection state changed: False -> True (Icon Active)")
        elif all_false_in_history:
            self.confirmed_detection_state = False
            if previous_confirmed_state is True: # Log only on change
                 self.logger.info("Confirmed detection state changed: True -> False (Icon Inactive)")
        else:
            # Mixed results in buffer, maintain previous confirmed state to avoid flapping
             self.logger.debug(f"Detection history contains mixed results. Confirmed state remains: {self.confirmed_detection_state}")

        return self.confirmed_detection_state


if __name__ == "__main__":
    import sys
    import time # Required for time.sleep in temporal test
    # Set up a basic logger for testing
    test_logger = logging.getLogger("IconDetectorTest")
    test_logger.setLevel(logging.DEBUG)
    if not test_logger.handlers: # Avoid adding multiple handlers if run again
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s'))
        test_logger.addHandler(handler)

    print("\n--- Testing Basic Icon Detection ---")
    icon_detector_basic = IconDetector(test_logger, temporal_consistency_frames=1)

    frame = np.random.randint(0, 256, (300, 300, 3), dtype=np.uint8)
    test_logger.info(f"Created dummy frame with shape: {frame.shape}")
    template_coords = (50, 50, 100, 100)
    x, y, w, h = template_coords
    template = frame[y:y+h, x:x+w].copy()
    test_logger.info(f"Created dummy template with shape: {template.shape}")

    print("\nTest 1: Exact template match (should be found)")
    found, score, loc = icon_detector_basic.detect_icon(frame, template, 0.99)
    print(f"Result: found={found}, confidence={score:.4f}, location={loc}")
    assert found is True, "Test 1 Failed: Exact match not found"

    print("\nTest 2: Random template (should not be found)")
    random_template = np.random.randint(0, 256, (50, 50, 3), dtype=np.uint8)
    found, score, loc = icon_detector_basic.detect_icon(frame, random_template, 0.8)
    print(f"Result: found={found}, confidence={score:.4f}, location={loc}")
    assert found is False, "Test 2 Failed: Random template was found"

    print("\nTest 3: Template larger than frame (should fail gracefully)")
    large_template = np.random.randint(0, 256, (400, 400, 3), dtype=np.uint8)
    found, score, loc = icon_detector_basic.detect_icon(frame, large_template, 0.8)
    print(f"Result: found={found}, confidence={score:.4f}, location={loc}")
    assert found is False and score == 0.0 and loc is None, "Test 3 Failed: Template larger than frame did not fail gracefully"

    print("\n--- Testing Temporal Consistency ---")
    consistency_frames = 3
    icon_detector_temporal = IconDetector(test_logger, temporal_consistency_frames=consistency_frames)

    # Initial state: confirmed_detection_state = False
    # History deque maxlen is consistency_frames (3)
    test_sequence_temporal = [
        # (current_frame_found, expected_confirmed_state_after_update)
        (True, False),  # History: [T], Buffer not full (len 1/3), Confirmed: False
        (True, False),  # History: [T, T], Buffer not full (len 2/3), Confirmed: False
        (True, True),   # History: [T, T, T], Buffer full, All True, Confirmed: True (State Change)
        (False, True),  # History: [T, T, F], Buffer full, Mixed, Confirmed: True (No Change)
        (False, True),  # History: [T, F, F], Buffer full, Mixed, Confirmed: True (No Change)
        (False, False), # History: [F, F, F], Buffer full, All False, Confirmed: False (State Change)
        (False, False), # History: [F, F, F], Buffer full, All False, Confirmed: False (No Change)
        (True, False),  # History: [F, F, T], Buffer full, Mixed, Confirmed: False (No Change)
        (True, False),  # History: [F, T, T], Buffer full, Mixed, Confirmed: False (No Change)
        (True, True),   # History: [T, T, T], Buffer full, All True, Confirmed: True (State Change)
    ]

    icon_detector_temporal.detection_history.clear()
    icon_detector_temporal.confirmed_detection_state = False # Explicitly set initial state
    test_logger.info(f"Starting temporal consistency test. `temporal_consistency_frames` = {consistency_frames}. Initial `confirmed_detection_state` = False.")

    all_tests_passed = True
    for i, (current_found, expected_confirmed) in enumerate(test_sequence_temporal):
        print(f"\nEvent {i+1}: Input Raw Found = {current_found}, Current Confirmed State = {icon_detector_temporal.confirmed_detection_state}, History = {list(icon_detector_temporal.detection_history)}")
        actual_confirmed = icon_detector_temporal.update_consistent_detection_state(current_found)
        print(f" -> Output Confirmed State = {actual_confirmed} (Expected: {expected_confirmed})")
        if actual_confirmed != expected_confirmed:
            all_tests_passed = False
            print(f"   ❌ FAILED: Expected {expected_confirmed}, got {actual_confirmed}")
        else:
            print(f"   ✅ PASSED")
        time.sleep(0.01)

    print("\nTemporal Consistency Test Summary:")
    if all_tests_passed:
        print("✅ All temporal consistency tests passed.")
    else:
        print("❌ Some temporal consistency tests failed.")

    print("\n--- IconDetector Test Complete ---")

```
Provided content for `src/daoc_sprint_manager/core/icon_detector.py`.

Next, the `InputManager`.

```python name=src/daoc_sprint_manager/core/input_manager.py
"""
Manages keyboard input simulation using pydirectinput.

Provides methods to safely press, release, and send keypresses, primarily
for interacting with game clients or other applications. Includes validation
for supported key codes.
"""

import logging
import time
from typing import Set

try:
    import pydirectinput
    # Populate VALID_KEYS once at import time
    VALID_KEYS: Set[str] = set(pydirectinput.KEY_NAMES)
    PYDIRECTINPUT_AVAILABLE = True
except ImportError:
    VALID_KEYS: Set[str] = set(['a', 'b', 'c', 'space', 'enter', 'f1', 'f6', 'r', 'z', 'up', 'down', 'left', 'right']) # Example keys
    PYDIRECTINPUT_AVAILABLE = False


class InputManager:
    """
    Handles sending keyboard inputs using pydirectinput.

    Encapsulates key press and release actions, including validation and delays.

    CRITICAL USER RESPONSIBILITY: Automated input may violate game End User
    License Agreements (EULA). Use of this module is at the user's own risk.
    Ensure compliance with all game rules to avoid account penalties.
    """

    def __init__(self, logger: logging.Logger):
        """
        Initializes the InputManager.

        Args:
            logger: Logger instance for recording operations and errors.
        """
        self.logger = logger
        if not PYDIRECTINPUT_AVAILABLE:
            self.logger.critical(
                "pydirectinput library is not installed. Input functionality will not work. "
                "Install it using: pip install pydirectinput"
            )
        else:
            # Configure pydirectinput if needed (e.g., pause behavior)
            # pydirectinput.PAUSE = 0.01 # Default is 0.1, can be lowered
            pass
        self.logger.debug("InputManager initialized.")

    def _is_valid_key(self, key_code: str) -> bool:
        """
        Checks if the given key code is valid according to pydirectinput.

        Args:
            key_code: The key code string (e.g., 'a', 'f6', 'space').

        Returns:
            True if the key code is valid, False otherwise.
        """
        is_valid = key_code.lower() in VALID_KEYS
        if not is_valid:
            self.logger.warning(f"Invalid key code '{key_code}' specified. Supported keys: {sorted(list(VALID_KEYS[:10]))}... etc.")
        return is_valid

    def press_key(self, key_code: str) -> None:
        """
        Simulates pressing and holding down a key (keyDown).

        Args:
            key_code: The key code to press (must be a valid pydirectinput key).

        Raises:
            RuntimeError: If pydirectinput is not available.
        """
        if not PYDIRECTINPUT_AVAILABLE:
            self.logger.error("Cannot press key: pydirectinput is not available.")
            raise RuntimeError("pydirectinput is not installed")

        if not self._is_valid_key(key_code):
            return

        try:
            self.logger.debug(f"Pressing key (keyDown): '{key_code}'")
            pydirectinput.keyDown(key_code)
        except Exception as e: # Catching general Exception as pydirectinput might raise various things
            self.logger.error(f"pydirectinput error pressing key (keyDown) '{key_code}': {e}", exc_info=True)
            # Decide if to re-raise or handle gracefully
            # For now, log and continue is safer for an automation tool.
            # raise

    def release_key(self, key_code: str) -> None:
        """
        Simulates releasing a key (keyUp).

        Args:
            key_code: The key code to release (must be a valid pydirectinput key).

        Raises:
            RuntimeError: If pydirectinput is not available.
        """
        if not PYDIRECTINPUT_AVAILABLE:
            self.logger.error("Cannot release key: pydirectinput is not available.")
            raise RuntimeError("pydirectinput is not installed")

        if not self._is_valid_key(key_code):
            return

        try:
            self.logger.debug(f"Releasing key (keyUp): '{key_code}'")
            pydirectinput.keyUp(key_code)
        except Exception as e:
            self.logger.error(f"pydirectinput error releasing key (keyUp) '{key_code}': {e}", exc_info=True)
            # raise

    def send_keypress(self, key_code: str, press_duration_ms: int = 50) -> None:
        """
        Simulates a full keypress (keyDown, wait, keyUp).

        Args:
            key_code: The key code to send (must be a valid pydirectinput key).
            press_duration_ms: The duration to hold the key down in milliseconds. Minimum 10ms.

        Raises:
            RuntimeError: If pydirectinput is not available.
        """
        if not PYDIRECTINPUT_AVAILABLE:
            self.logger.error("Cannot send keypress: pydirectinput is not available.")
            raise RuntimeError("pydirectinput is not installed")

        if not self._is_valid_key(key_code):
            self.logger.warning(f"Skipping send_keypress for invalid key: {key_code}")
            return

        try:
            self.logger.info(f"Sending keypress: '{key_code}' (duration: {press_duration_ms}ms)")
            pydirectinput.keyDown(key_code)
            time.sleep(max(0.01, press_duration_ms / 1000.0)) # Ensure a minimum sleep of 10ms
            pydirectinput.keyUp(key_code)
            self.logger.debug(f"Keypress '{key_code}' completed.")
        except Exception as e:
            self.logger.error(f"pydirectinput error sending keypress '{key_code}': {e}", exc_info=True)
            # raise


if __name__ == "__main__":
    import sys
    # Set up a basic logger for testing
    test_logger = logging.getLogger("InputManagerTest")
    test_logger.setLevel(logging.DEBUG)
    if not test_logger.handlers:
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s'))
        test_logger.addHandler(handler)

    input_manager = InputManager(test_logger)

    if not PYDIRECTINPUT_AVAILABLE:
        test_logger.critical("pydirectinput is not installed. InputManager tests cannot be fully executed.")
        print("Please install pydirectinput: pip install pydirectinput")
    else:
        print("\n--- Testing InputManager ---")
        print("CRITICAL: This test will send a keypress.")
        print("Please focus a text editor (like Notepad) within the next 5 seconds.")
        print("A 'z' keypress will be sent.")
        for i in range(5, 0, -1):
            print(f"{i}...", end=" ", flush=True)
            time.sleep(1)
        print("Sending!")

        try:
            print("\nTest 1: Sending 'z' keypress (duration 100ms)...")
            input_manager.send_keypress('z', press_duration_ms=100)
            print("-> Check your text editor for the 'z' character.")
        except RuntimeError as e:
            print(f"   ERROR during keypress: {e} (This is expected if pydirectinput is missing)")
        except Exception as e:
            print(f"   UNEXPECTED ERROR during keypress: {e}")

        time.sleep(2)

        try:
            print("\nTest 2: Sending an invalid key ('invalidkeyname')...")
            input_manager.send_keypress('invalidkeyname', press_duration_ms=50)
            print("-> This should log a warning and not send anything if the key is truly invalid.")
        except RuntimeError as e:
            print(f"   ERROR during invalid keypress: {e} (This is expected if pydirectinput is missing)")
        except Exception as e:
            print(f"   UNEXPECTED ERROR during invalid keypress: {e}")


        print("\nTest 3: Testing press/release separately ('b' key)...")
        print("Focus text editor again in 3 seconds...")
        time.sleep(3)
        print("   Pressing 'b'...")
        try:
            input_manager.press_key('b')
            time.sleep(0.5) # Hold for 0.5 sec
            print("   Releasing 'b'...")
            input_manager.release_key('b')
            print("-> If focus was on text editor, 'b' might appear.")
        except RuntimeError as e:
            print(f"   ERROR during press/release: {e} (This is expected if pydirectinput is missing)")
        except Exception as e:
            print(f"   UNEXPECTED ERROR during press/release test: {e}")


        print("\n--- InputManager Test Complete ---")
        print("Please verify the output in your text editor.")

```
Provided content for `src/daoc_sprint_manager/core/input_manager.py`.

Next, `PerformanceMonitor`.

```python name=src/daoc_sprint_manager/utils/performance_monitor.py
"""
Utility for monitoring script performance metrics.

Provides methods to time code sections and retrieve system resource usage
(CPU, Memory) for the current process.
"""

import logging
import os
import time
from typing import Dict, Optional, Tuple

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

class PerformanceMonitor:
    """
    Monitors script performance including execution time and resource usage.
    """

    def __init__(self, logger: logging.Logger):
        """
        Initializes the PerformanceMonitor.

        Args:
            logger: Logger instance for recording operations and errors.
        """
        self.logger = logger
        self.timers: Dict[str, float] = {}
        self.last_lap_times: Dict[str, float] = {}
        self.process: Optional[psutil.Process] = None

        if not PSUTIL_AVAILABLE:
            self.logger.warning(
                "psutil library is not installed. Resource monitoring will be disabled. "
                "Install it using: pip install psutil"
            )
        else:
            try:
                self.process = psutil.Process(os.getpid())
                # Prime the cpu_percent call as the first call returns 0 or requires interval for comparison
                self.process.cpu_percent(interval=None)
                self.logger.debug("PerformanceMonitor initialized with psutil.")
            except psutil.Error as e: # Catch specific psutil errors
                 self.logger.error(f"Could not get current process information using psutil: {e}. Resource monitoring disabled.")
                 self.process = None # Ensure process is None if init fails
            except Exception as e: # Catch any other unexpected error
                 self.logger.exception(f"Unexpected error initializing psutil.Process: {e}. Resource monitoring disabled.")
                 self.process = None


    def start_timer(self, name: str) -> None:
        """
        Starts a performance timer with the given name.

        Args:
            name: An identifier for the timer.
        """
        self.timers[name] = time.perf_counter()
        self.logger.debug(f"Timer '{name}' started.")

    def stop_timer(self, name: str) -> Optional[float]:
        """
        Stops the performance timer with the given name and returns the duration.

        Args:
            name: The identifier of the timer to stop.

        Returns:
            The elapsed time in seconds since the timer was started,
            or None if the timer name was not found.
        """
        if name not in self.timers:
            self.logger.error(f"Timer '{name}' was stopped but never started.")
            return None

        start_time = self.timers.pop(name) # Remove timer after stopping
        end_time = time.perf_counter()
        duration = end_time - start_time
        self.last_lap_times[name] = duration # Store the duration
        self.logger.debug(f"Timer '{name}' stopped. Duration: {duration:.6f} seconds.")
        return duration

    def get_fps(self, cycle_time_s: float) -> float:
        """
        Calculates Frames Per Second (FPS) based on a cycle time.

        Args:
            cycle_time_s: The duration of one cycle in seconds.

        Returns:
            The calculated FPS, or 0.0 if cycle time is non-positive or too small.
        """
        if cycle_time_s > 0.00001: # Avoid division by zero or very small numbers leading to huge FPS
            return 1.0 / cycle_time_s
        self.logger.debug(f"Cycle time {cycle_time_s:.6f}s too small or non-positive, returning 0.0 FPS.")
        return 0.0

    def get_script_resource_usage(self) -> Tuple[Optional[float], Optional[float]]:
        """
        Gets the current CPU and Memory usage for the script's process.

        Returns:
            A tuple containing:
            - float or None: CPU usage percentage (since last call or process start).
            - float or None: Memory usage in MB (Resident Set Size).
            Returns (None, None) if psutil is unavailable or fails.
        """
        if not self.process: # Check if psutil.Process object was successfully initialized
             self.logger.debug("Cannot get resource usage: psutil process not available or not initialized.")
             return None, None

        try:
            # cpu_percent(interval=None) returns the usage since the last call,
            # or since process creation if it's the first call without interval.
            cpu_percent: Optional[float] = self.process.cpu_percent(interval=None)

            # memory_info().rss gives the Resident Set Size in bytes
            memory_bytes = self.process.memory_info().rss
            memory_mb: Optional[float] = memory_bytes / (1024 * 1024) # Convert bytes to MB

            self.logger.debug(f"Resource usage: CPU={cpu_percent:.1f}%, Memory={memory_mb:.2f}MB" if cpu_percent is not None and memory_mb is not None else "Resource usage: Data unavailable")
            return cpu_percent, memory_mb

        except psutil.Error as e: # Catch specific psutil errors
             self.logger.error(f"psutil error getting resource usage: {e}")
             return None, None
        except Exception as e: # Catch any other unexpected error
             self.logger.exception(f"Unexpected error getting resource usage: {e}")
             return None, None


if __name__ == "__main__":
    import sys
    # Set up a basic logger for testing
    test_logger = logging.getLogger("PerfMonTest")
    test_logger.setLevel(logging.DEBUG)
    if not test_logger.handlers:
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s'))
        test_logger.addHandler(handler)

    monitor = PerformanceMonitor(test_logger)

    print("\n--- Testing PerformanceMonitor ---")

    # Test Timer functionality
    print("\nTest 1: Timing a short task...")
    monitor.start_timer("short_sleep")
    time.sleep(0.1534) # Sleep for ~153ms
    duration = monitor.stop_timer("short_sleep")
    if duration is not None:
        print(f" -> Measured duration: {duration:.4f} seconds (expected ~0.1534s)")
        assert 0.15 < duration < 0.16, "Timer duration out of expected range"
        print(f" -> Stored lap time: {monitor.last_lap_times.get('short_sleep'):.4f} seconds")
    else:
        print(" -> Failed to get duration for 'short_sleep'.")
        assert False, "stop_timer returned None unexpectedly"


    print("\nTest 2: Trying to stop a non-existent timer...")
    duration_fail = monitor.stop_timer("non_existent_timer")
    print(f" -> Result for 'non_existent_timer': {duration_fail} (expected None)")
    assert duration_fail is None, "Stopping non-existent timer should return None"

    # Test FPS calculation
    print("\nTest 3: Calculating FPS...")
    cycle_time_1 = 0.1 # Expected 10 FPS
    cycle_time_2 = 1.0 / 60.0 # Expected 60 FPS
    cycle_time_3 = 0.0 # Expected 0 FPS
    fps1 = monitor.get_fps(cycle_time_1)
    fps2 = monitor.get_fps(cycle_time_2)
    fps3 = monitor.get_fps(cycle_time_3)
    print(f" -> FPS for cycle time {cycle_time_1:.4f}s: {fps1:.1f} FPS (Expected: 10.0)")
    print(f" -> FPS for cycle time {cycle_time_2:.4f}s: {fps2:.1f} FPS (Expected: 60.0)")
    print(f" -> FPS for cycle time {cycle_time_3:.4f}s: {fps3:.1f} FPS (Expected: 0.0)")
    assert abs(fps1 - 10.0) < 0.1, f"FPS1 expected ~10.0, got {fps1}"
    assert abs(fps2 - 60.0) < 0.1, f"FPS2 expected ~60.0, got {fps2}"
    assert abs(fps3 - 0.0) < 0.0001, f"FPS3 expected 0.0, got {fps3}"


    # Test Resource Usage (if psutil is available)
    print("\nTest 4: Getting resource usage...")
    if monitor.process: # Check if psutil.Process object was initialized
        # Initial call, cpu_percent might be 0.0 or low
        cpu, mem = monitor.get_script_resource_usage()
        print(f" -> Initial Usage: CPU = {f'{cpu:.1f}%' if cpu is not None else 'N/A'}, Memory = {f'{mem:.2f}MB' if mem is not None else 'N/A'}")

        # Simulate some CPU work
        print(" -> Simulating CPU work (list comprehension)...")
        start_work_time = time.perf_counter()
        # This list comprehension will use some CPU
        _ = [x*x for x in range(2 * 10**6)] # Increased range for more noticeable CPU usage
        work_duration = time.perf_counter() - start_work_time
        print(f" -> CPU work took {work_duration:.3f}s")
        
        time.sleep(0.1) # Give psutil a moment to update after work

        cpu_after_work, mem_after_work = monitor.get_script_resource_usage()
        print(f" -> Usage after work: CPU = {f'{cpu_after_work:.1f}%' if cpu_after_work is not None else 'N/A'}, Memory = {f'{mem_after_work:.2f}MB' if mem_after_work is not None else 'N/A'}")
        if cpu_after_work is not None:
             assert cpu_after_work >= 0.0, "CPU usage should be non-negative"
        if mem_after_work is not None:
             assert mem_after_work > 0.0, "Memory usage should be positive"
    else:
        print(" -> Skipping resource usage test because psutil is not available or failed to initialize.")

    print("\n--- PerformanceMonitor Test Complete ---")
```
Provided content for `src/daoc_sprint_manager/utils/performance_monitor.py`.

Next, the updated `main.py` integrating the Performance Monitor.

```python name=src/daoc_sprint_manager/main.py
"""
Main application entry point for the DAOC Sprint Manager.

Initializes components, manages the main detection loop, handles
application lifecycle events, and incorporates performance monitoring.
"""

import logging
import pathlib
import sys
import time
import os # Added for os.chdir

try:
    import pygetwindow
    PYGETWINDOW_AVAILABLE = True
except ImportError:
    PYGETWINDOW_AVAILABLE = False
    print("WARNING: pygetwindow library not found. Window focus checking will be disabled. Install with: pip install pygetwindow")


# Import project modules
try:
    # For direct execution of this file
    from utils.logger import setup_logger
    from config_manager import ConfigManager
    from data_models import AppSettings
    from core.window_manager import WindowManager
    from core.icon_detector import IconDetector
    from core.input_manager import InputManager # Added
    from utils.performance_monitor import PerformanceMonitor # Added
except ImportError:
    # When imported as a module within the package
    from .utils.logger import setup_logger
    from .config_manager import ConfigManager
    from .data_models import AppSettings
    from .core.window_manager import WindowManager
    from .core.icon_detector import IconDetector
    from .core.input_manager import InputManager # Added
    from .utils.performance_monitor import PerformanceMonitor # Added


# Define ROOT_DIR relative to this file's location
ROOT_DIR = pathlib.Path(__file__).resolve().parent.parent.parent
LOGS_DIR = ROOT_DIR / "logs"


def run_application():
    """Initializes and runs the main application logic."""
    # --- Preliminary Setup ---
    prelim_log_file = LOGS_DIR / "startup_app.log"
    try:
        LOGS_DIR.mkdir(parents=True, exist_ok=True)
        prelim_logger = setup_logger("startup", prelim_log_file, logging.DEBUG)
        prelim_logger.info(f"Preliminary logging started. Project Root: {ROOT_DIR}")
    except Exception as e:
        print(f"FATAL: Could not set up preliminary logger at {prelim_log_file}: {e}", file=sys.stderr)
        sys.exit(1)

    # --- Configuration Loading ---
    main_logger = prelim_logger
    try:
        settings_file = ROOT_DIR / "config" / "settings.json"
        template_file = ROOT_DIR / "config" / "settings.json.template"
        main_logger.info(f"Settings path: {settings_file}")
        main_logger.info(f"Template path: {template_file}")

        config_manager = ConfigManager(settings_file, template_file, main_logger)
        app_settings: AppSettings = config_manager.load_settings()

        # --- Main Logger Setup ---
        actual_log_file_path = LOGS_DIR / app_settings.log_file_name
        log_level_from_config = getattr(logging, app_settings.log_level.upper(), logging.INFO)
        main_logger = setup_logger("DAOCSprintManager", actual_log_file_path, log_level_from_config)
        main_logger.info("Main application logger initialized.")
        main_logger.info(f"Logging to file: {actual_log_file_path}")
        main_logger.info(f"Log level set to: {app_settings.log_level}")

    except Exception as e:
        main_logger.critical(f"Failed during configuration or main logger setup: {e}", exc_info=True)
        sys.exit(1)

    # --- Check Dependencies ---
    if not PYGETWINDOW_AVAILABLE:
        main_logger.critical("pygetwindow library is not installed. Focus checking functionality will be severely limited or non-functional.")
        # Depending on strictness, could sys.exit(1) here. For now, allow degraded mode.

    # --- Application Start ---
    main_logger.info("Application initializing...")
    main_logger.debug(f"Loaded settings: {app_settings}")
    main_logger.debug(f"Project Root Directory: {ROOT_DIR}")

    # --- Initialize Core Components ---
    try:
        perf_monitor = PerformanceMonitor(main_logger) # Instantiate Perf Monitor
        main_logger.info("Performance monitor initialized.")

        window_manager = WindowManager(main_logger)
        main_logger.info("Window manager initialized.")

        icon_detector = IconDetector(main_logger, app_settings.temporal_consistency_frames)
        main_logger.info("Icon detector initialized.")

        input_manager = InputManager(main_logger)
        main_logger.info("Input manager initialized.")

        sprint_on_template_path = ROOT_DIR / app_settings.sprint_on_icon_path
        loaded_template = icon_detector.load_template(sprint_on_template_path)

        if loaded_template is None:
            main_logger.critical(f"Failed to load sprint 'ON' icon template from {sprint_on_template_path}. Exiting.")
            sys.exit(1)
        main_logger.info("Sprint 'ON' icon template loaded successfully.")

    except Exception as e:
        main_logger.critical(f"Failed during component initialization: {e}", exc_info=True)
        sys.exit(1)

    # --- Main Detection Loop ---
    main_logger.info("Starting main detection loop...")
    sprint_key_physical_state: bool = False
    try:
        while True:
            perf_monitor.start_timer("full_cycle") # Start full cycle timer

            find_time = capture_time = detection_time = None # Reset timers for this iteration

            # --- Find Window ---
            perf_monitor.start_timer("window_find")
            game_window = window_manager.find_window(app_settings.game_window_title)
            find_time = perf_monitor.stop_timer("window_find")

            if game_window is None:
                main_logger.warning(f"Game window '{app_settings.game_window_title}' not found. Retrying in {app_settings.game_not_found_retry_delay_s}s...")
                if sprint_key_physical_state:
                    try:
                        input_manager.release_key(app_settings.sprint_key)
                        sprint_key_physical_state = False
                        main_logger.info(f"Sprint key '{app_settings.sprint_key}' RELEASED. Reason: Game window lost.")
                    except Exception as release_err:
                         main_logger.error(f"Error releasing key after game window lost: {release_err}")
                # Stop full cycle timer here before continuing to get accurate sleep
                full_cycle_time = perf_monitor.stop_timer("full_cycle") # Get current cycle time before sleep
                time.sleep(app_settings.game_not_found_retry_delay_s)
                continue

            # --- Capture ROI ---
            perf_monitor.start_timer("roi_capture")
            frame = window_manager.capture_roi_from_window(
                game_window,
                app_settings.roi_x,
                app_settings.roi_y,
                app_settings.roi_width,
                app_settings.roi_height
            )
            capture_time = perf_monitor.stop_timer("roi_capture")

            if frame is None:
                main_logger.warning(f"Failed to capture ROI from game window. Retrying in {app_settings.capture_error_retry_delay_s}s...")
                if sprint_key_physical_state:
                    main_logger.warning("ROI capture failed while sprint key is potentially held down.")
                full_cycle_time = perf_monitor.stop_timer("full_cycle")
                time.sleep(app_settings.capture_error_retry_delay_s)
                continue

            # --- Detect Icon ---
            perf_monitor.start_timer("icon_detection")
            raw_found, score, loc_rect = icon_detector.detect_icon(
                frame,
                loaded_template,
                app_settings.template_match_threshold
            )
            detection_time = perf_monitor.stop_timer("icon_detection")

            # --- Temporal Consistency ---
            confirmed_icon_is_active = icon_detector.update_consistent_detection_state(raw_found)
            main_logger.debug(f"Detection Frame: RawFound={raw_found}, Score={score:.2f}, ConfirmedState={confirmed_icon_is_active}, Location={loc_rect}")


            # --- Input Logic ---
            is_game_focused = False
            active_win_title = "N/A (pygetwindow not available or error)"
            if PYGETWINDOW_AVAILABLE:
                try:
                    active_win = pygetwindow.getActiveWindow()
                    if active_win and app_settings.game_window_title.lower() in active_win.title.lower():
                        is_game_focused = True
                    active_win_title = active_win.title if active_win else "None"
                except Exception as focus_err: # Catch broader exceptions from pygetwindow
                     main_logger.warning(f"Could not get active window title: {focus_err}")
            else: # If pygetwindow is not available, we cannot determine focus, so we might act cautiously
                main_logger.debug("pygetwindow not available, cannot check game window focus. Proceeding with input logic based on icon state only.")
                # Fallback behavior: If pygetwindow is missing, assume game is focused if window was found.
                # This is a simplification. A real app might handle this more gracefully
                # or make focus checking a hard requirement.
                is_game_focused = True if game_window else False


            if confirmed_icon_is_active and not sprint_key_physical_state and is_game_focused:
                try:
                    input_manager.press_key(app_settings.sprint_key)
                    sprint_key_physical_state = True
                    main_logger.info(f"Sprint key '{app_settings.sprint_key}' PRESSED. Reason: Icon confirmed active, key was released, game focused.")
                except Exception as press_err:
                    main_logger.error(f"Error pressing sprint key '{app_settings.sprint_key}': {press_err}")
            elif not confirmed_icon_is_active and sprint_key_physical_state:
                try:
                    input_manager.release_key(app_settings.sprint_key)
                    sprint_key_physical_state = False
                    main_logger.info(f"Sprint key '{app_settings.sprint_key}' RELEASED. Reason: Icon confirmed inactive, key was pressed.")
                except Exception as release_err:
                    main_logger.error(f"Error releasing sprint key '{app_settings.sprint_key}': {release_err}")
            elif confirmed_icon_is_active and sprint_key_physical_state and not is_game_focused:
                 try:
                    input_manager.release_key(app_settings.sprint_key)
                    sprint_key_physical_state = False
                    main_logger.info(f"Sprint key '{app_settings.sprint_key}' RELEASED. Reason: Game window ('{app_settings.game_window_title}') lost focus. Active window: '{active_win_title}'.")
                 except Exception as release_err:
                    main_logger.error(f"Error releasing key on focus loss '{app_settings.sprint_key}': {release_err}")
            elif confirmed_icon_is_active and not sprint_key_physical_state and not is_game_focused:
                 main_logger.debug(f"Sprint icon active, but game window ('{app_settings.game_window_title}') not focused. Active window: '{active_win_title}'. Sprint key press skipped.")


            # --- Performance Logging & Loop Delay ---
            full_cycle_time = perf_monitor.stop_timer("full_cycle")

            if app_settings.show_performance_metrics and full_cycle_time is not None:
                fps = perf_monitor.get_fps(full_cycle_time)
                cpu_usage, mem_usage_mb = perf_monitor.get_script_resource_usage()
                cpu_str = f"{cpu_usage:.1f}" if cpu_usage is not None else "N/A"
                mem_str = f"{mem_usage_mb:.1f}" if mem_usage_mb is not None else "N/A"
                find_ms_str = f"{find_time*1000:.1f}" if find_time is not None else 'N/A'
                capture_ms_str = f"{capture_time*1000:.1f}" if capture_time is not None else 'N/A'
                detect_ms_str = f"{detection_time*1000:.1f}" if detection_time is not None else 'N/A'

                main_logger.debug(
                    f"Perf: Cycle={full_cycle_time*1000:.2f}ms (FPS:{fps:.1f}), "
                    f"CPU={cpu_str}%, MEM={mem_str}MB. "
                    f"Timings(ms): Find={find_ms_str}, Capture={capture_ms_str}, Detect={detect_ms_str}"
                )

            # Calculate sleep duration based on full cycle time
            target_delay = 1.0 / app_settings.capture_fps if app_settings.capture_fps > 0 else 0.1
            current_elapsed_time = full_cycle_time if full_cycle_time is not None else 0
            sleep_duration = max(0, target_delay - current_elapsed_time)

            if full_cycle_time is not None : # Only log if full_cycle_time is valid
                main_logger.debug(f"Loop finished in {current_elapsed_time*1000:.1f}ms. Sleeping for {sleep_duration:.4f}s.")
            else:
                main_logger.debug(f"Full cycle time is None. Defaulting sleep based on target_delay. Sleeping for {sleep_duration:.4f}s.")

            time.sleep(sleep_duration)

    except KeyboardInterrupt:
        main_logger.info("Application terminated by user (KeyboardInterrupt).")
    except Exception as e: # Catch any other unhandled exceptions in the main loop
        main_logger.critical(f"Unhandled exception in main loop: {e}", exc_info=True)
        if sprint_key_physical_state: # Attempt to release key on error
            try:
                main_logger.warning("Releasing sprint key due to unexpected application exit.")
                input_manager.release_key(app_settings.sprint_key)
            except Exception as final_release_err:
                 main_logger.error(f"Error during final key release on unhandled exception: {final_release_err}")
        return 1 # Indicate error exit
    finally:
        if sprint_key_physical_state:
            try:
                main_logger.info("Releasing sprint key on application shutdown (finally block).")
                input_manager.release_key(app_settings.sprint_key)
            except Exception as final_release_err:
                 main_logger.error(f"Error during final key release on shutdown (finally block): {final_release_err}")
        main_logger.info("Application shutdown sequence complete.")
        return 0 # Indicate normal or planned exit


if __name__ == "__main__":
    # --- PyInstaller / Path Setup ---
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
         # Running as a bundled app (e.g., PyInstaller)
         # sys._MEIPASS is the temp dir PyInstaller creates
         ROOT_DIR = pathlib.Path(sys._MEIPASS)
         print(f"Running as bundled app, _MEIPASS ROOT_DIR set to: {ROOT_DIR}")
    else:
         # Running as a script, ROOT_DIR defined above is correct
         print(f"Running as script, ROOT_DIR: {ROOT_DIR}")
         # If run directly, ensure CWD is project root for relative paths in config
         try:
             os.chdir(ROOT_DIR)
             print(f"Changed CWD to: {os.getcwd()}")
         except Exception as e:
             print(f"Could not change CWD to ROOT_DIR {ROOT_DIR}: {e}")


    # Setup basic logging immediately in case run_application fails early
    initial_logger = logging.getLogger("main_entry")
    initial_logger.setLevel(logging.INFO)
    if not initial_logger.handlers: # Avoid adding multiple handlers
        initial_handler = logging.StreamHandler(sys.stdout)
        initial_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s')
        initial_handler.setFormatter(initial_formatter)
        initial_logger.addHandler(initial_handler)

    exit_code = 1 # Default to error
    try:
        exit_code = run_application()
        if exit_code == 0:
            initial_logger.info("Application finished normally.")
        else:
            initial_logger.error(f"Application exited with error code: {exit_code}")

    except KeyboardInterrupt:
        initial_logger.info("Application terminated by user from __main__ (KeyboardInterrupt).")
        exit_code = 0 # User termination is not an error
    except Exception as e: # Catch-all for __main__
         initial_logger.critical(f"Critical unhandled exception in __main__: {e}", exc_info=True)
         exit_code = 1
    finally:
        initial_logger.info("Main execution block finished.")
        logging.shutdown() # Ensure all handlers are flushed
        print("Main shutdown sequence complete.")
        sys.exit(exit_code)
```
Provided content for `src/daoc_sprint_manager/main.py`.

Next, the `SprintManagerApp` class in `tray_app.py`.

```python name=src/daoc_sprint_manager/ui/tray_app.py
"""
System tray application class for DAOC Sprint Manager.

Handles the system tray icon, menu, threading for the detection loop,
and overall application lifecycle management.
"""

import logging
import os
import pathlib
import subprocess
import sys
import threading
import time
from typing import Optional

try:
    import pystray
    from PIL import Image, UnidentifiedImageError
    PYSTRAY_AVAILABLE = True
except ImportError:
    PYSTRAY_AVAILABLE = False
    # This module is critical for the tray app. Logging will be done in __init__.

try:
    import pygetwindow
    PYGETWINDOW_AVAILABLE = True
except ImportError:
    PYGETWINDOW_AVAILABLE = False
    # Warning will be logged if this is missing, as focus checking will be degraded.


# Import project components
# This structure assumes tray_app.py is in src/daoc_sprint_manager/ui/
# Adjust relative imports if the file structure is different.
try:
    from ..data_models import AppSettings
    from ..core.window_manager import WindowManager
    from ..core.icon_detector import IconDetector
    from ..core.input_manager import InputManager
    from ..utils.performance_monitor import PerformanceMonitor
except ImportError:
    # This block is for cases where the script might be run directly for testing
    # or if the package structure isn't correctly recognized by the Python path.
    # It tries to adjust sys.path to allow direct imports from sibling directories.
    # This is a common pattern but might need adjustment based on specific project layout.
    current_dir = pathlib.Path(__file__).parent.resolve()
    project_src_dir = current_dir.parent # Moves up one level from 'ui' to 'daoc_sprint_manager'
    if str(project_src_dir) not in sys.path:
         sys.path.insert(0, str(project_src_dir))
    
    from data_models import AppSettings
    from core.window_manager import WindowManager
    from core.icon_detector import IconDetector
    from core.input_manager import InputManager
    from utils.performance_monitor import PerformanceMonitor

class SprintManagerApp:
    """
    Manages the system tray application, detection loop thread, and state.
    """

    def __init__(self, app_settings: AppSettings, logger: logging.Logger, root_dir: pathlib.Path):
        """
        Initializes the SprintManagerApp.

        Args:
            app_settings: Loaded application settings.
            logger: Logger instance.
            root_dir: The root directory of the project.
        """
        self.app_settings = app_settings
        self.logger = logger
        self.root_dir = root_dir

        if not PYSTRAY_AVAILABLE:
            self.logger.critical("pystray or Pillow library not found. System tray UI cannot run. Install using: pip install pystray Pillow")
            sys.exit("FATAL: Missing required libraries (pystray, Pillow) for tray application.")
        
        if not PYGETWINDOW_AVAILABLE:
            self.logger.warning("pygetwindow library not found. Game window focus checking will be disabled. Install using: pip install pygetwindow")


        # --- Shared State ---
        self.stop_event = threading.Event()
        self.pause_event = threading.Event()
        self.status_message: str = "Initializing..."
        self.status_lock = threading.Lock()
        self.pystray_icon: Optional[pystray.Icon] = None
        self.sprint_key_physical_state: bool = False
        self.detection_thread: Optional[threading.Thread] = None

        # --- Initialize Core Components ---
        self.perf_monitor = PerformanceMonitor(self.logger)
        self.window_manager = WindowManager(self.logger)
        self.icon_detector = IconDetector(self.logger, self.app_settings.temporal_consistency_frames)
        self.input_manager = InputManager(self.logger)

        # --- Load Template ---
        sprint_on_template_path = self.root_dir / self.app_settings.sprint_on_icon_path
        self.sprint_on_template = self.icon_detector.load_template(sprint_on_template_path)
        if self.sprint_on_template is None:
             self.logger.critical(f"Failed to load sprint 'ON' template from {sprint_on_template_path}. Application cannot start.")
             sys.exit(f"FATAL: Sprint 'ON' template missing at {sprint_on_template_path}.")

        self.logger.info("SprintManagerApp initialized successfully.")

    def _update_status(self, message: str):
        """Thread-safely update the status message and tray icon tooltip."""
        with self.status_lock:
            self.status_message = message
            if self.pystray_icon:
                 self.pystray_icon.title = f"DAOC Sprint Manager: {self.status_message}"
                 # pystray typically updates its menu when its 'menu' property is accessed
                 # or via icon.update_menu() if supported by the backend.
                 # For dynamic text in menu items, the menu property getter is often used.
        self.logger.info(f"Status updated: {message}")


    def _on_clicked_pause_resume(self, icon: Optional[pystray.Icon], item: Optional[pystray.MenuItem]):
        """Callback for the Pause/Resume menu item."""
        if self.pause_event.is_set():
            self.pause_event.clear()
            self._update_status("Running")
            self.logger.info("Application Resumed.")
        else:
            self.pause_event.set()
            self._update_status("Paused")
            self.logger.info("Application Paused.")
        if self.pystray_icon: # Ensure menu is re-rendered if check state changes
             self.pystray_icon.update_menu()


    def _on_clicked_open_config(self, icon: Optional[pystray.Icon], item: Optional[pystray.MenuItem]):
        """Callback for the Open Config menu item."""
        config_path = self.root_dir / "config" / "settings.json"
        self.logger.info(f"Attempting to open config file: {config_path}")
        try:
            if not config_path.exists():
                 self.logger.error(f"Config file {config_path} does not exist. Cannot open.")
                 # Optionally, try to create it from template if it's missing entirely
                 template_path = self.root_dir / "config" / "settings.json.template"
                 if template_path.exists():
                     shutil.copy(template_path, config_path)
                     self.logger.info(f"Created {config_path} from template. Please edit and restart if needed.")
                 else:
                     self.logger.error(f"Template file {template_path} also missing. Cannot create config.")
                     return

            if sys.platform == "win32":
                os.startfile(str(config_path))
            elif sys.platform == "darwin":
                subprocess.call(['open', str(config_path)])
            else: # Linux and other Unix-like
                subprocess.call(['xdg-open', str(config_path)])
        except FileNotFoundError: # Should be handled by exists check, but good for robustness
            self.logger.error(f"Config file not found at {config_path} during open attempt.")
        except Exception as e:
            self.logger.exception(f"Error opening config file {config_path}: {e}")

    def _on_clicked_exit(self, icon: Optional[pystray.Icon], item: Optional[pystray.MenuItem]):
        """Callback for the Exit menu item."""
        self.logger.info("Exit requested from tray menu.")
        self._update_status("Exiting...")
        self.stop_event.set()
        if self.pystray_icon:
            self.pystray_icon.stop()

    @property
    def menu(self) -> pystray.Menu:
        """Dynamically generates the tray menu."""
        paused_state = self.pause_event.is_set()
        status_item_text = f"Status: {self.status_message}"

        return pystray.Menu(
            pystray.MenuItem(status_item_text, None, enabled=False),
            pystray.Menu.SEPARATOR,
            pystray.MenuItem(
                'Pause' if not paused_state else 'Resume',
                self._on_clicked_pause_resume,
                checked=lambda item: self.pause_event.is_set() # Check dynamically
            ),
            pystray.MenuItem('Open Config', self._on_clicked_open_config),
            pystray.MenuItem('Exit', self._on_clicked_exit)
        )

    def run_detection_logic(self):
        """The main detection loop that runs in a separate thread."""
        self.logger.info("Detection thread started.")
        last_perf_log_time = time.monotonic()

        while not self.stop_event.is_set():
            loop_start_time = time.monotonic()

            if self.pause_event.is_set():
                if self.sprint_key_physical_state:
                    try:
                        self.input_manager.release_key(self.app_settings.sprint_key)
                        self.sprint_key_physical_state = False
                        self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' RELEASED due to pause.")
                    except Exception as release_err:
                         self.logger.error(f"Error releasing key on pause: {release_err}")
                self.stop_event.wait(timeout=1.0) # Check stop_event periodically while paused
                continue

            self.perf_monitor.start_timer("full_cycle")
            find_time, capture_time, detection_time = None, None, None

            self.perf_monitor.start_timer("window_find")
            game_window = self.window_manager.find_window(self.app_settings.game_window_title)
            find_time = self.perf_monitor.stop_timer("window_find")

            if game_window is None:
                self._update_status("Game Not Found")
                if self.sprint_key_physical_state:
                     try:
                         self.input_manager.release_key(self.app_settings.sprint_key)
                         self.sprint_key_physical_state = False
                         self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' RELEASED (Game window lost).")
                     except Exception as release_err:
                         self.logger.error(f"Error releasing key (Game window lost): {release_err}")
                self.perf_monitor.stop_timer("full_cycle") # Stop timer before sleep
                self.stop_event.wait(timeout=self.app_settings.game_not_found_retry_delay_s)
                continue

            self.perf_monitor.start_timer("roi_capture")
            frame = self.window_manager.capture_roi_from_window(
                game_window, self.app_settings.roi_x, self.app_settings.roi_y,
                self.app_settings.roi_width, self.app_settings.roi_height
            )
            capture_time = self.perf_monitor.stop_timer("roi_capture")

            if frame is None:
                self._update_status("Capture Error")
                if self.sprint_key_physical_state:
                    self.logger.warning("ROI capture failed while sprint key is potentially held down.")
                self.perf_monitor.stop_timer("full_cycle")
                self.stop_event.wait(timeout=self.app_settings.capture_error_retry_delay_s)
                continue

            self.perf_monitor.start_timer("icon_detection")
            raw_found, score, _ = self.icon_detector.detect_icon(
                frame, self.sprint_on_template, self.app_settings.template_match_threshold
            )
            detection_time = self.perf_monitor.stop_timer("icon_detection")
            confirmed_icon_is_active = self.icon_detector.update_consistent_detection_state(raw_found)
            current_status_msg = "Icon Active" if confirmed_icon_is_active else "Icon Inactive"

            is_game_focused = False
            active_win_title = "N/A (pygetwindow error or not available)"
            if PYGETWINDOW_AVAILABLE:
                try:
                    active_win = pygetwindow.getActiveWindow()
                    if active_win and self.app_settings.game_window_title.lower() in active_win.title.lower():
                        is_game_focused = True
                    active_win_title = active_win.title if active_win else "None"
                except Exception as focus_err:
                    self.logger.warning(f"Could not get active window title: {focus_err}")
            else: # Fallback if pygetwindow is missing
                 is_game_focused = True # Assume focused if library missing, to allow core functionality

            if confirmed_icon_is_active and not self.sprint_key_physical_state and is_game_focused:
                try:
                    self.input_manager.press_key(self.app_settings.sprint_key)
                    self.sprint_key_physical_state = True
                    self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' PRESSED.")
                except Exception as press_err:
                    self.logger.error(f"Error pressing sprint key: {press_err}")
            elif not confirmed_icon_is_active and self.sprint_key_physical_state:
                try:
                    self.input_manager.release_key(self.app_settings.sprint_key)
                    self.sprint_key_physical_state = False
                    self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' RELEASED (Icon inactive).")
                except Exception as release_err:
                    self.logger.error(f"Error releasing sprint key: {release_err}")
            elif confirmed_icon_is_active and self.sprint_key_physical_state and not is_game_focused:
                 try:
                    self.input_manager.release_key(self.app_settings.sprint_key)
                    self.sprint_key_physical_state = False
                    self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' RELEASED (Game lost focus: '{active_win_title}').")
                 except Exception as release_err:
                     self.logger.error(f"Error releasing key on focus loss: {release_err}")

            full_cycle_time = self.perf_monitor.stop_timer("full_cycle")
            current_time_mono = time.monotonic()
            if self.app_settings.show_performance_metrics and (current_time_mono - last_perf_log_time >= 5.0):
                if full_cycle_time is not None:
                    fps = self.perf_monitor.get_fps(full_cycle_time)
                    cpu, mem = self.perf_monitor.get_script_resource_usage()
                    self.logger.debug(
                        f"Perf: Cycle={full_cycle_time*1000:.1f}ms (FPS:{fps:.1f}), "
                        f"CPU={cpu if cpu is not None else 'N/A'}%, MEM={f'{mem:.1f}MB' if mem is not None else 'N/A'}. "
                        f"Timings(ms): Find={find_time*1000 if find_time else 'N/A':.1f}, "
                        f"Capture={capture_time*1000 if capture_time else 'N/A':.1f}, "
                        f"Detect={detection_time*1000 if detection_time else 'N/A':.1f}"
                    )
                    self._update_status(f"{current_status_msg} (FPS:{fps:.1f})")
                    last_perf_log_time = current_time_mono

            loop_end_time_mono = time.monotonic()
            elapsed_this_loop = loop_end_time_mono - loop_start_time
            target_loop_delay = 1.0 / self.app_settings.capture_fps if self.app_settings.capture_fps > 0 else 0.1
            sleep_duration = max(0, target_loop_delay - elapsed_this_loop)

            if sleep_duration > 0:
                self.stop_event.wait(timeout=sleep_duration)

        self.logger.info("Detection thread finished.")
        if self.sprint_key_physical_state:
            try:
                self.input_manager.release_key(self.app_settings.sprint_key)
                self.logger.info(f"Sprint key '{self.app_settings.sprint_key}' released on thread exit.")
            except Exception as e:
                self.logger.error(f"Error releasing key on thread exit: {e}")


    def start(self):
        """Starts the system tray application and the detection thread."""
        self.logger.info("Starting SprintManagerApp...")
        icon_image = None
        try:
            app_icon_path_resolved = self.root_dir / self.app_settings.app_icon_path
            if app_icon_path_resolved.is_file():
                icon_image = Image.open(app_icon_path_resolved)
                self.logger.info(f"Loaded application icon: {app_icon_path_resolved}")
            else:
                self.logger.warning(f"App icon not found at {app_icon_path_resolved}, using default.")
        except Exception as e:
            self.logger.exception(f"Error loading application icon '{self.app_settings.app_icon_path}': {e}. Using default icon.")

        self.detection_thread = threading.Thread(target=self.run_detection_logic, daemon=True)
        self.detection_thread.start()

        self.pystray_icon = pystray.Icon(
            "DAOCSprintManager",
            icon=icon_image,
            title="DAOC Sprint Manager",
            menu=self.menu # Use property for dynamic menu
        )
        self._update_status("Running")
        try:
            self.pystray_icon.run() # Blocks until icon.stop() is called
        except Exception as e:
            self.logger.critical(f"Pystray icon run error: {e}", exc_info=True)
            self.stop_event.set() # Ensure detection thread stops
        finally:
            self.logger.info("Pystray icon loop has finished.")
            self.stop_event.set() # Signal thread to stop if not already
            if self.detection_thread and self.detection_thread.is_alive():
                self.logger.info("Waiting for detection thread to join...")
                self.detection_thread.join(timeout=5.0)
                if self.detection_thread.is_alive():
                    self.logger.warning("Detection thread did not cleanly join.")
            self.logger.info("SprintManagerApp fully stopped.")
```
Provided content for `src/daoc_sprint_manager/ui/tray_app.py`.

Finally, the refactored `main.py`.

```python name=src/daoc_sprint_manager/main.py
"""
Main application entry point for the DAOC Sprint Manager.

Initializes configuration, logging, and the system tray application.
"""

import logging
import pathlib
import sys
import os
import threading # For the main app thread if needed, though pystray blocks

# Ensure the project root is added to sys.path for imports if needed
# This makes 'python -m src.daoc_sprint_manager.main' work from project root
# and also helps if 'main.py' is run directly from its directory (though less ideal).
current_file_path = pathlib.Path(__file__).resolve()
# Assuming main.py is in src/daoc_sprint_manager/
# project_root should be daoc_sprint_manager/
# src_root should be daoc_sprint_manager/src/
# module_root should be daoc_sprint_manager/src/daoc_sprint_manager
PROJECT_ROOT_DIR = current_file_path.parent.parent.parent

# Add src to path to allow 'from daoc_sprint_manager...'
SRC_DIR = PROJECT_ROOT_DIR / 'src'
if str(SRC_DIR) not in sys.path:
    sys.path.insert(0, str(SRC_DIR))


try:
    # Attempt to import project modules using the package name
    from daoc_sprint_manager.config_manager import ConfigManager
    from daoc_sprint_manager.data_models import AppSettings
    from daoc_sprint_manager.ui.tray_app import SprintManagerApp, PYSTRAY_AVAILABLE
    from daoc_sprint_manager.utils.logger import setup_logger
except ImportError as e:
    print(f"Import Error: {e}. This script expects to be run in an environment where "
          "the 'daoc_sprint_manager' package is accessible. "
          "Try running with `python -m daoc_sprint_manager.main` from the project root "
          "or ensure PYTHONPATH is set correctly.", file=sys.stderr)
    sys.exit(1)


LOGS_DIR = PROJECT_ROOT_DIR / "logs" # Logs directory in project root

def run_main_application():
    """Initializes and runs the main application logic via the tray app."""
    # --- Preliminary Setup ---
    prelim_log_file = LOGS_DIR / "startup_app.log"
    try:
        LOGS_DIR.mkdir(parents=True, exist_ok=True)
        prelim_logger = setup_logger("startup", prelim_log_file, logging.DEBUG)
        prelim_logger.info(f"Preliminary logging started. Project Root: {PROJECT_ROOT_DIR}")
    except Exception as e:
        print(f"FATAL: Could not set up preliminary logger at {prelim_log_file}: {e}", file=sys.stderr)
        sys.exit(1)

    # --- Configuration Loading ---
    main_logger = prelim_logger
    app_settings: Optional[AppSettings] = None # Initialize to satisfy type checker
    try:
        settings_file = PROJECT_ROOT_DIR / "config" / "settings.json"
        template_file = PROJECT_ROOT_DIR / "config" / "settings.json.template"
        main_logger.info(f"Settings path: {settings_file}")
        main_logger.info(f"Template path: {template_file}")

        config_manager = ConfigManager(settings_file, template_file, main_logger)
        app_settings = config_manager.load_settings()

        # --- Main Logger Setup ---
        actual_log_file_path = LOGS_DIR / app_settings.log_file_name
        log_level_str = app_settings.log_level.upper()
        log_level_int = getattr(logging, log_level_str, logging.INFO) # Default to INFO
        if not isinstance(log_level_int, int): # Check if getattr failed
            main_logger.warning(f"Invalid log level '{app_settings.log_level}' in settings. Defaulting to INFO.")
            log_level_int = logging.INFO
        
        main_logger = setup_logger("DAOCSprintManager", actual_log_file_path, log_level_int)
        main_logger.info("Main application logger initialized.")
        main_logger.info(f"Logging to file: {actual_log_file_path}")
        main_logger.info(f"Log level set to: {logging.getLevelName(main_logger.level)}")

    except Exception as e:
        main_logger.critical(f"Failed during configuration or main logger setup: {e}", exc_info=True)
        sys.exit(1) # Exit if basic setup fails

    # --- Initialize and Start Tray Application ---
    if not PYSTRAY_AVAILABLE:
        main_logger.critical("pystray or Pillow not found. Cannot run system tray application.")
        print("ERROR: pystray or Pillow library not found. Install using: pip install pystray Pillow", file=sys.stderr)
        sys.exit(1)

    main_logger.info("Initializing SprintManagerApp...")
    # Ensure app_settings is not None before passing
    if app_settings is None:
        main_logger.critical("app_settings was not loaded. Exiting.")
        sys.exit(1)
        
    app = SprintManagerApp(app_settings, main_logger, PROJECT_ROOT_DIR)
    main_logger.info("Starting SprintManagerApp...")
    
    # Store app instance in a way that KeyboardInterrupt handler might access it
    # This is a bit of a workaround for direct signal handling by pystray
    _app_instance_holder["app"] = app

    try:
        app.start() # This call blocks until the tray application exits
    except KeyboardInterrupt:
        main_logger.info("KeyboardInterrupt received by main.py during app.start(). Stopping app.")
        if _app_instance_holder["app"]:
            _app_instance_holder["app"]._on_clicked_exit(None, None) # type: ignore
    except Exception as e:
        main_logger.critical(f"Unhandled exception during SprintManagerApp.start(): {e}", exc_info=True)
        if _app_instance_holder["app"]: # Try to gracefully shutdown
            _app_instance_holder["app"]._on_clicked_exit(None, None) # type: ignore
        sys.exit(1)


    # --- Post-Application Run ---
    main_logger.info("Application finished running.")
    return 0

_app_instance_holder = {"app": None} # Global-like holder for app instance

if __name__ == "__main__":
    # Set CWD to project root if running as script for relative paths in config/icon loading
    if not getattr(sys, 'frozen', False): # Not running as a bundled exe
        try:
            os.chdir(PROJECT_ROOT_DIR)
            print(f"Successfully changed CWD to: {os.getcwd()}")
        except Exception as e:
            print(f"Warning: Could not change CWD to project root ({PROJECT_ROOT_DIR}): {e}")
    else: # Running as bundled exe
        # For PyInstaller, PROJECT_ROOT_DIR might be sys._MEIPASS or executable's dir
        # Ensure this is handled correctly if resources are bundled.
        # For now, we assume PROJECT_ROOT_DIR as defined points to the right place.
        print(f"Running as bundled app. Effective ROOT_DIR: {PROJECT_ROOT_DIR}")


    # Setup basic logging immediately for __main__ block
    initial_logger = logging.getLogger("main_entry_point")
    initial_logger.setLevel(logging.INFO)
    if not initial_logger.handlers:
        initial_handler = logging.StreamHandler(sys.stdout)
        initial_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        initial_handler.setFormatter(initial_formatter)
        initial_logger.addHandler(initial_handler)

    exit_code = 1 # Default to error
    try:
        exit_code = run_main_application()
        if exit_code == 0:
            initial_logger.info("Application run completed successfully.")
        else:
            initial_logger.error(f"Application run exited with error code: {exit_code}")

    except KeyboardInterrupt:
        initial_logger.info("KeyboardInterrupt received in __main__. Application should be stopping via tray app.")
        # The SprintManagerApp's exit handler should manage cleanup.
        # Pystray usually handles SIGINT; if not, the app.start() try-except should catch it.
        if _app_instance_holder["app"]:
            app_instance = _app_instance_holder["app"]
            if app_instance.pystray_icon and not app_instance.stop_event.is_set():
                initial_logger.info("Manually triggering app exit due to KeyboardInterrupt in __main__.")
                app_instance._on_clicked_exit(None, None) # type: ignore
        exit_code = 0
    except Exception as e:
        initial_logger.critical(f"Critical unhandled exception in __main__ execution: {e}", exc_info=True)
        if _app_instance_holder["app"]: # Try to gracefully shutdown
            app_instance = _app_instance_holder["app"]
            if app_instance.pystray_icon and not app_instance.stop_event.is_set():
                app_instance._on_clicked_exit(None, None) # type: ignore
        exit_code = 1
    finally:
        initial_logger.info("Main execution block finished.")
        logging.shutdown() # Ensure all handlers are flushed
        print("Main Python script shutdown complete.")
        sys.exit(exit_code)
```
Provided content for `src/daoc_sprint_manager/main.py`.

And here is the user task reminder:
```
User Task: Provide an application icon named 'app_icon.png' (e.g., 32x32 or 64x64 pixels) in the 'PythonSprint/data/' directory. This icon will be used for the system tray. The path is also configurable in settings.json.template as app_icon_path.
```

All Phase 2 files have been provided. The conceptual memory bank and documentation are updated to reflect the completion of Phase 2.

This is an ideal time to transition context to a new session agent.

---

**Handoff Prompt for Next AI Agent (Gemini 2.5 Pro Orchestrator)**

```text
# DAOC Sprint Manager - Project Handoff: Start Phase 3

## Project Overview & Current Status
You are the **Orchestrator AI (Gemini 2.5 Pro)** for the "DAOC Sprint Manager" project. This Python application automates sprint buff management in Dark Age of Camelot.
- **Phase 1 (Foundation & Basic Detection)**: COMPLETE.
- **Phase 2 (Advanced Detection & Input System)**: COMPLETE. This included temporal consistency in detection, keyboard input management via pydirectinput, performance monitoring, and a basic system tray UI using pystray. The application can successfully identify the game window, capture ROI, detect sprint icon with temporal consistency, simulate key presses based on game window focus, and provides a system tray icon for basic control (Pause/Resume, Open Config, Exit).
- **Current State**: The application is functional with a system tray UI.

## Your Current Task: Initiate and Oversee Phase 3
You will now begin **Phase 3: Robustness & ML Implementation (Optional)** as detailed in the `PythonSprintPlan.md`. Your immediate task is to implement **Phase 3, Step 1: ML-Based Icon Detection**.

## Phase 3, Step 1: ML-Based Icon Detection - Detailed Instructions

Follow these steps meticulously, adhering to all Universal Code Quality and Architectural Standards outlined in `PythonSprintPlan.md`:

1.  **Update `PythonSprint/requirements.txt`**: Add `onnxruntime` to the project dependencies.
2.  **Output User Task Reminder**: Provide the "ML Model User Task" text exactly as specified in the plan. This text guides the human user on manual tasks related to dataset collection and model training for the ML feature.
3.  **Update Data Models and Configuration Template**:
    *   Modify `PythonSprint/src/daoc_sprint_manager/data_models.py`: Add `ml_model_path: str`, `ml_input_size_wh: list[int]`, and `ml_confidence_threshold: float` to the `AppSettings` dataclass with their specified default values.
    *   Modify `PythonSprint/config/settings.json.template`: Add the corresponding keys and default values for these new ML settings.
4.  **Implement `MLDetector` Class**:
    *   Create a new file: `PythonSprint/src/daoc_sprint_manager/core/ml_detector.py`.
    *   Implement the `MLDetector` class with the structure and methods (`__init__`, `_preprocess_image`, `predict`) precisely as defined in `PythonSprintPlan.md`.
    *   Include an `if __name__ == "__main__":` block for self-testing. This test will require a dummy ONNX model and a dummy image. Provide clear instructions within the self-test comments on how a user should create/place these dummy files for the test to be runnable.

5.  **Deliverables**:
    *   Full content of `PythonSprint/src/daoc_sprint_manager/core/ml_detector.py`.
    *   Updated content of `PythonSprint/src/daoc_sprint_manager/data_models.py`.
    *   Updated content of `PythonSprint/config/settings.json.template`.
    *   Updated content of `PythonSprint/requirements.txt`.

## Development Guidelines & Tools

*   **Primary Reference**: The `PythonSprintPlan.md` document.
*   **Quality Standards**: Enforce PEP 8, type hinting, Google Style docstrings, robust error handling, and module self-tests.
*   **File Operations**: Use `pathlib.Path`.
*   **Encoding**: Specify `encoding='utf-8'` for file operations.
*   **MCP Tools**: Use `read_file`, `edit_file`, `create_file` for file operations. Provide complete, runnable code for the entire file when editing or creating.
*   **Memory Bank**: All previously generated files (Phase 1 & 2 deliverables) and the `PythonSprintPlan.md` are considered part of the Memory Bank.
*   **Iterative Approach**: Implement each sub-task sequentially.

## Starting Point
Begin by updating `PythonSprint/requirements.txt`. Then, provide the "ML Model User Task Reminder" output. After that, update `data_models.py` and `config/settings.json.template`. Finally, implement the `MLDetector` class.

**After completing all deliverables for Phase 3, Step 1, explicitly state "Phase 3, Step 1 deliverables complete." and await further instructions.**
```

---

_**Assistant**_



---

I see that all Phase 3, Step 1 deliverables (ML-Based Detection) have already been implemented correctly:

1. ✅ `requirements.txt` already includes `onnxruntime>=1.14.0`
2. ✅ ML settings have been added to `data_models.py`:
   - `ml_model_path` (defaulting to "data/models/sprint_classifier.onnx")
   - `ml_input_size_wh` (defaulting to [32, 32])
   - `ml_confidence_threshold` (defaulting to 0.7)
   - Validators for these fields are also implemented

3. ✅ `settings.json.template` has been updated with the ML settings
4. ✅ `ml_detector.py` has been implemented with:
   - Proper imports and error handling for missing dependencies
   - `MLDetector` class with initialization, preprocessing, and prediction functions
   - Detailed self-test code and instructions for creating test files

All the code follows the project's design patterns with proper error handling, logging, type hints, and follows the module pattern described in the system patterns documentation.

The implementation includes graceful handling of missing dependencies, proper validation of input data, and thorough logging - which aligns with the project's robustness requirements.

The ML-based detection is ready to be used as an alternative to template matching once a user provides a trained model.

---

_**User**_

Please update our memory bank and documentation  - then pepare a context transition documents to hand-off work to the next AI agent. Use our MCP Servers (SequentialThinking, Memory, Git, Puppeteer, CONTEXT7 FOR EXAMPLE CODE) to store and pass all necessary data and context for development in the next AI Agent session. Acceptance criteria for task completion includes a prompt that will be provided to the next session agent.

---

_**Assistant**_



---



---

